/*!
 * Bootstrap v5.0.0-beta1 (https://getbootstrap.com/)
 * Copyright 2011-2020 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */
! function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : (global = "undefined" != typeof globalThis ? globalThis : global || self).bootstrap = factory()
}(this, (function() {
    "use strict";

    function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
        }
    }

    function _createClass(Constructor, protoProps, staticProps) {
        return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor
    }

    function _extends() {
        return _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key])
            }
            return target
        }, _extends.apply(this, arguments)
    }

    function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, subClass.__proto__ = superClass
    }
    var storeData, id, getUID = function(prefix) {
            do {
                prefix += Math.floor(1e6 * Math.random())
            } while (document.getElementById(prefix));
            return prefix
        },
        getSelector = function(element) {
            var selector = element.getAttribute("data-bs-target");
            if (!selector || "#" === selector) {
                var hrefAttr = element.getAttribute("href");
                selector = hrefAttr && "#" !== hrefAttr ? hrefAttr.trim() : null
            }
            return selector
        },
        getSelectorFromElement = function(element) {
            var selector = getSelector(element);
            return selector && document.querySelector(selector) ? selector : null
        },
        getElementFromSelector = function(element) {
            var selector = getSelector(element);
            return selector ? document.querySelector(selector) : null
        },
        getTransitionDurationFromElement = function(element) {
            if (!element) return 0;
            var _window$getComputedSt = window.getComputedStyle(element),
                transitionDuration = _window$getComputedSt.transitionDuration,
                transitionDelay = _window$getComputedSt.transitionDelay,
                floatTransitionDuration = Number.parseFloat(transitionDuration),
                floatTransitionDelay = Number.parseFloat(transitionDelay);
            return floatTransitionDuration || floatTransitionDelay ? (transitionDuration = transitionDuration.split(",")[0], transitionDelay = transitionDelay.split(",")[0], 1e3 * (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay))) : 0
        },
        triggerTransitionEnd = function(element) {
            element.dispatchEvent(new Event("transitionend"))
        },
        isElement = function(obj) {
            return (obj[0] || obj).nodeType
        },
        emulateTransitionEnd = function(element, duration) {
            var called = !1,
                emulatedDuration = duration + 5;
            element.addEventListener("transitionend", (function listener() {
                called = !0, element.removeEventListener("transitionend", listener)
            })), setTimeout((function() {
                called || triggerTransitionEnd(element)
            }), emulatedDuration)
        },
        typeCheckConfig = function(componentName, config, configTypes) {
            Object.keys(configTypes).forEach((function(property) {
                var obj, expectedTypes = configTypes[property],
                    value = config[property],
                    valueType = value && isElement(value) ? "element" : null == (obj = value) ? "" + obj : {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
                if (!new RegExp(expectedTypes).test(valueType)) throw new Error(componentName.toUpperCase() + ': Option "' + property + '" provided type "' + valueType + '" but expected type "' + expectedTypes + '".')
            }))
        },
        isVisible = function(element) {
            if (!element) return !1;
            if (element.style && element.parentNode && element.parentNode.style) {
                var elementStyle = getComputedStyle(element),
                    parentNodeStyle = getComputedStyle(element.parentNode);
                return "none" !== elementStyle.display && "none" !== parentNodeStyle.display && "hidden" !== elementStyle.visibility
            }
            return !1
        },
        findShadowRoot = function findShadowRoot(element) {
            if (!document.documentElement.attachShadow) return null;
            if ("function" == typeof element.getRootNode) {
                var root = element.getRootNode();
                return root instanceof ShadowRoot ? root : null
            }
            return element instanceof ShadowRoot ? element : element.parentNode ? findShadowRoot(element.parentNode) : null
        },
        noop = function() {
            return function() {}
        },
        reflow = function(element) {
            return element.offsetHeight
        },
        getjQuery = function() {
            var jQuery = window.jQuery;
            return jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? jQuery : null
        },
        onDOMContentLoaded = function(callback) {
            "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", callback) : callback()
        },
        isRTL = "rtl" === document.documentElement.dir,
        mapData = (storeData = {}, id = 1, {
            set: function(element, key, data) {
                void 0 === element.bsKey && (element.bsKey = {
                    key: key,
                    id: id
                }, id++), storeData[element.bsKey.id] = data
            },
            get: function(element, key) {
                if (!element || void 0 === element.bsKey) return null;
                var keyProperties = element.bsKey;
                return keyProperties.key === key ? storeData[keyProperties.id] : null
            },
            delete: function(element, key) {
                if (void 0 !== element.bsKey) {
                    var keyProperties = element.bsKey;
                    keyProperties.key === key && (delete storeData[keyProperties.id], delete element.bsKey)
                }
            }
        }),
        Data_setData = function(instance, key, data) {
            mapData.set(instance, key, data)
        },
        Data_getData = function(instance, key) {
            return mapData.get(instance, key)
        },
        Data_removeData = function(instance, key) {
            mapData.delete(instance, key)
        },
        namespaceRegex = /[^.]*(?=\..*)\.|.*/,
        stripNameRegex = /\..*/,
        stripUidRegex = /::\d+$/,
        eventRegistry = {},
        uidEvent = 1,
        customEvents = {
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        },
        nativeEvents = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

    function getUidEvent(element, uid) {
        return uid && uid + "::" + uidEvent++ || element.uidEvent || uidEvent++
    }

    function getEvent(element) {
        var uid = getUidEvent(element);
        return element.uidEvent = uid, eventRegistry[uid] = eventRegistry[uid] || {}, eventRegistry[uid]
    }

    function findHandler(events, handler, delegationSelector) {
        void 0 === delegationSelector && (delegationSelector = null);
        for (var uidEventList = Object.keys(events), i = 0, len = uidEventList.length; i < len; i++) {
            var event = events[uidEventList[i]];
            if (event.originalHandler === handler && event.delegationSelector === delegationSelector) return event
        }
        return null
    }

    function normalizeParams(originalTypeEvent, handler, delegationFn) {
        var delegation = "string" == typeof handler,
            originalHandler = delegation ? delegationFn : handler,
            typeEvent = originalTypeEvent.replace(stripNameRegex, ""),
            custom = customEvents[typeEvent];
        return custom && (typeEvent = custom), nativeEvents.has(typeEvent) || (typeEvent = originalTypeEvent), [delegation, originalHandler, typeEvent]
    }

    function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
        if ("string" == typeof originalTypeEvent && element) {
            handler || (handler = delegationFn, delegationFn = null);
            var _normalizeParams = normalizeParams(originalTypeEvent, handler, delegationFn),
                delegation = _normalizeParams[0],
                originalHandler = _normalizeParams[1],
                typeEvent = _normalizeParams[2],
                events = getEvent(element),
                handlers = events[typeEvent] || (events[typeEvent] = {}),
                previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);
            if (previousFn) previousFn.oneOff = previousFn.oneOff && oneOff;
            else {
                var uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, "")),
                    fn = delegation ? function(element, selector, fn) {
                        return function handler(event) {
                            for (var domElements = element.querySelectorAll(selector), target = event.target; target && target !== this; target = target.parentNode)
                                for (var i = domElements.length; i--;)
                                    if (domElements[i] === target) return event.delegateTarget = target, handler.oneOff && EventHandler.off(element, event.type, fn), fn.apply(target, [event]);
                            return null
                        }
                    }(element, handler, delegationFn) : function(element, fn) {
                        return function handler(event) {
                            return event.delegateTarget = element, handler.oneOff && EventHandler.off(element, event.type, fn), fn.apply(element, [event])
                        }
                    }(element, handler);
                fn.delegationSelector = delegation ? handler : null, fn.originalHandler = originalHandler, fn.oneOff = oneOff, fn.uidEvent = uid, handlers[uid] = fn, element.addEventListener(typeEvent, fn, delegation)
            }
        }
    }

    function removeHandler(element, events, typeEvent, handler, delegationSelector) {
        var fn = findHandler(events[typeEvent], handler, delegationSelector);
        fn && (element.removeEventListener(typeEvent, fn, Boolean(delegationSelector)), delete events[typeEvent][fn.uidEvent])
    }
    var EventHandler = {
            on: function(element, event, handler, delegationFn) {
                addHandler(element, event, handler, delegationFn, !1)
            },
            one: function(element, event, handler, delegationFn) {
                addHandler(element, event, handler, delegationFn, !0)
            },
            off: function(element, originalTypeEvent, handler, delegationFn) {
                if ("string" == typeof originalTypeEvent && element) {
                    var _normalizeParams2 = normalizeParams(originalTypeEvent, handler, delegationFn),
                        delegation = _normalizeParams2[0],
                        originalHandler = _normalizeParams2[1],
                        typeEvent = _normalizeParams2[2],
                        inNamespace = typeEvent !== originalTypeEvent,
                        events = getEvent(element),
                        isNamespace = originalTypeEvent.startsWith(".");
                    if (void 0 === originalHandler) {
                        isNamespace && Object.keys(events).forEach((function(elementEvent) {
                            ! function(element, events, typeEvent, namespace) {
                                var storeElementEvent = events[typeEvent] || {};
                                Object.keys(storeElementEvent).forEach((function(handlerKey) {
                                    if (handlerKey.includes(namespace)) {
                                        var event = storeElementEvent[handlerKey];
                                        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector)
                                    }
                                }))
                            }(element, events, elementEvent, originalTypeEvent.slice(1))
                        }));
                        var storeElementEvent = events[typeEvent] || {};
                        Object.keys(storeElementEvent).forEach((function(keyHandlers) {
                            var handlerKey = keyHandlers.replace(stripUidRegex, "");
                            if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
                                var event = storeElementEvent[keyHandlers];
                                removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector)
                            }
                        }))
                    } else {
                        if (!events || !events[typeEvent]) return;
                        removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null)
                    }
                }
            },
            trigger: function(element, event, args) {
                if ("string" != typeof event || !element) return null;
                var jQueryEvent, $ = getjQuery(),
                    typeEvent = event.replace(stripNameRegex, ""),
                    inNamespace = event !== typeEvent,
                    isNative = nativeEvents.has(typeEvent),
                    bubbles = !0,
                    nativeDispatch = !0,
                    defaultPrevented = !1,
                    evt = null;
                return inNamespace && $ && (jQueryEvent = $.Event(event, args), $(element).trigger(jQueryEvent), bubbles = !jQueryEvent.isPropagationStopped(), nativeDispatch = !jQueryEvent.isImmediatePropagationStopped(), defaultPrevented = jQueryEvent.isDefaultPrevented()), isNative ? (evt = document.createEvent("HTMLEvents")).initEvent(typeEvent, bubbles, !0) : evt = new CustomEvent(event, {
                    bubbles: bubbles,
                    cancelable: !0
                }), void 0 !== args && Object.keys(args).forEach((function(key) {
                    Object.defineProperty(evt, key, {
                        get: function() {
                            return args[key]
                        }
                    })
                })), defaultPrevented && evt.preventDefault(), nativeDispatch && element.dispatchEvent(evt), evt.defaultPrevented && void 0 !== jQueryEvent && jQueryEvent.preventDefault(), evt
            }
        },
        BaseComponent = function() {
            function BaseComponent(element) {
                element && (this._element = element, Data_setData(element, this.constructor.DATA_KEY, this))
            }
            return BaseComponent.prototype.dispose = function() {
                Data_removeData(this._element, this.constructor.DATA_KEY), this._element = null
            }, BaseComponent.getInstance = function(element) {
                return Data_getData(element, this.DATA_KEY)
            }, _createClass(BaseComponent, null, [{
                key: "VERSION",
                get: function() {
                    return "5.0.0-beta1"
                }
            }]), BaseComponent
        }(),
        NAME = "alert",
        Alert = function(_BaseComponent) {
            function Alert() {
                return _BaseComponent.apply(this, arguments) || this
            }
            _inheritsLoose(Alert, _BaseComponent);
            var _proto = Alert.prototype;
            return _proto.close = function(element) {
                var rootElement = element ? this._getRootElement(element) : this._element,
                    customEvent = this._triggerCloseEvent(rootElement);
                null === customEvent || customEvent.defaultPrevented || this._removeElement(rootElement)
            }, _proto._getRootElement = function(element) {
                return getElementFromSelector(element) || element.closest(".alert")
            }, _proto._triggerCloseEvent = function(element) {
                return EventHandler.trigger(element, "close.bs.alert")
            }, _proto._removeElement = function(element) {
                var _this = this;
                if (element.classList.remove("show"), element.classList.contains("fade")) {
                    var transitionDuration = getTransitionDurationFromElement(element);
                    EventHandler.one(element, "transitionend", (function() {
                        return _this._destroyElement(element)
                    })), emulateTransitionEnd(element, transitionDuration)
                } else this._destroyElement(element)
            }, _proto._destroyElement = function(element) {
                element.parentNode && element.parentNode.removeChild(element), EventHandler.trigger(element, "closed.bs.alert")
            }, Alert.jQueryInterface = function(config) {
                return this.each((function() {
                    var data = Data_getData(this, "bs.alert");
                    data || (data = new Alert(this)), "close" === config && data[config](this)
                }))
            }, Alert.handleDismiss = function(alertInstance) {
                return function(event) {
                    event && event.preventDefault(), alertInstance.close(this)
                }
            }, _createClass(Alert, null, [{
                key: "DATA_KEY",
                get: function() {
                    return "bs.alert"
                }
            }]), Alert
        }(BaseComponent);
    EventHandler.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', Alert.handleDismiss(new Alert)), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn[NAME];
            $.fn[NAME] = Alert.jQueryInterface, $.fn[NAME].Constructor = Alert, $.fn[NAME].noConflict = function() {
                return $.fn[NAME] = JQUERY_NO_CONFLICT, Alert.jQueryInterface
            }
        }
    }));
    var Button = function(_BaseComponent) {
        function Button() {
            return _BaseComponent.apply(this, arguments) || this
        }
        return _inheritsLoose(Button, _BaseComponent), Button.prototype.toggle = function() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
        }, Button.jQueryInterface = function(config) {
            return this.each((function() {
                var data = Data_getData(this, "bs.button");
                data || (data = new Button(this)), "toggle" === config && data[config]()
            }))
        }, _createClass(Button, null, [{
            key: "DATA_KEY",
            get: function() {
                return "bs.button"
            }
        }]), Button
    }(BaseComponent);

    function normalizeData(val) {
        return "true" === val || "false" !== val && (val === Number(val).toString() ? Number(val) : "" === val || "null" === val ? null : val)
    }

    function normalizeDataKey(key) {
        return key.replace(/[A-Z]/g, (function(chr) {
            return "-" + chr.toLowerCase()
        }))
    }
    EventHandler.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', (function(event) {
        event.preventDefault();
        var button = event.target.closest('[data-bs-toggle="button"]'),
            data = Data_getData(button, "bs.button");
        data || (data = new Button(button)), data.toggle()
    })), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn.button;
            $.fn.button = Button.jQueryInterface, $.fn.button.Constructor = Button, $.fn.button.noConflict = function() {
                return $.fn.button = JQUERY_NO_CONFLICT, Button.jQueryInterface
            }
        }
    }));
    var Manipulator = {
            setDataAttribute: function(element, key, value) {
                element.setAttribute("data-bs-" + normalizeDataKey(key), value)
            },
            removeDataAttribute: function(element, key) {
                element.removeAttribute("data-bs-" + normalizeDataKey(key))
            },
            getDataAttributes: function(element) {
                if (!element) return {};
                var attributes = {};
                return Object.keys(element.dataset).filter((function(key) {
                    return key.startsWith("bs")
                })).forEach((function(key) {
                    var pureKey = key.replace(/^bs/, "");
                    pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length), attributes[pureKey] = normalizeData(element.dataset[key])
                })), attributes
            },
            getDataAttribute: function(element, key) {
                return normalizeData(element.getAttribute("data-bs-" + normalizeDataKey(key)))
            },
            offset: function(element) {
                var rect = element.getBoundingClientRect();
                return {
                    top: rect.top + document.body.scrollTop,
                    left: rect.left + document.body.scrollLeft
                }
            },
            position: function(element) {
                return {
                    top: element.offsetTop,
                    left: element.offsetLeft
                }
            }
        },
        SelectorEngine = {
            matches: function(element, selector) {
                return element.matches(selector)
            },
            find: function(selector, element) {
                var _ref;
                return void 0 === element && (element = document.documentElement), (_ref = []).concat.apply(_ref, Element.prototype.querySelectorAll.call(element, selector))
            },
            findOne: function(selector, element) {
                return void 0 === element && (element = document.documentElement), Element.prototype.querySelector.call(element, selector)
            },
            children: function(element, selector) {
                var _ref2, children = (_ref2 = []).concat.apply(_ref2, element.children);
                return children.filter((function(child) {
                    return child.matches(selector)
                }))
            },
            parents: function(element, selector) {
                for (var parents = [], ancestor = element.parentNode; ancestor && ancestor.nodeType === Node.ELEMENT_NODE && 3 !== ancestor.nodeType;) this.matches(ancestor, selector) && parents.push(ancestor), ancestor = ancestor.parentNode;
                return parents
            },
            prev: function(element, selector) {
                for (var previous = element.previousElementSibling; previous;) {
                    if (previous.matches(selector)) return [previous];
                    previous = previous.previousElementSibling
                }
                return []
            },
            next: function(element, selector) {
                for (var next = element.nextElementSibling; next;) {
                    if (this.matches(next, selector)) return [next];
                    next = next.nextElementSibling
                }
                return []
            }
        },
        NAME$2 = "carousel",
        EVENT_KEY$2 = ".bs.carousel",
        Default = {
            interval: 5e3,
            keyboard: !0,
            slide: !1,
            pause: "hover",
            wrap: !0,
            touch: !0
        },
        DefaultType = {
            interval: "(number|boolean)",
            keyboard: "boolean",
            slide: "(boolean|string)",
            pause: "(string|boolean)",
            wrap: "boolean",
            touch: "boolean"
        },
        PointerType = {
            TOUCH: "touch",
            PEN: "pen"
        },
        Carousel = function(_BaseComponent) {
            function Carousel(element, config) {
                var _this;
                return (_this = _BaseComponent.call(this, element) || this)._items = null, _this._interval = null, _this._activeElement = null, _this._isPaused = !1, _this._isSliding = !1, _this.touchTimeout = null, _this.touchStartX = 0, _this.touchDeltaX = 0, _this._config = _this._getConfig(config), _this._indicatorsElement = SelectorEngine.findOne(".carousel-indicators", _this._element), _this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, _this._pointerEvent = Boolean(window.PointerEvent), _this._addEventListeners(), _this
            }
            _inheritsLoose(Carousel, _BaseComponent);
            var _proto = Carousel.prototype;
            return _proto.next = function() {
                this._isSliding || this._slide("next")
            }, _proto.nextWhenVisible = function() {
                !document.hidden && isVisible(this._element) && this.next()
            }, _proto.prev = function() {
                this._isSliding || this._slide("prev")
            }, _proto.pause = function(event) {
                event || (this._isPaused = !0), SelectorEngine.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
            }, _proto.cycle = function(event) {
                event || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
            }, _proto.to = function(index) {
                var _this2 = this;
                this._activeElement = SelectorEngine.findOne(".active.carousel-item", this._element);
                var activeIndex = this._getItemIndex(this._activeElement);
                if (!(index > this._items.length - 1 || index < 0))
                    if (this._isSliding) EventHandler.one(this._element, "slid.bs.carousel", (function() {
                        return _this2.to(index)
                    }));
                    else {
                        if (activeIndex === index) return this.pause(), void this.cycle();
                        var direction = index > activeIndex ? "next" : "prev";
                        this._slide(direction, this._items[index])
                    }
            }, _proto.dispose = function() {
                _BaseComponent.prototype.dispose.call(this), EventHandler.off(this._element, EVENT_KEY$2), this._items = null, this._config = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
            }, _proto._getConfig = function(config) {
                return config = _extends({}, Default, config), typeCheckConfig(NAME$2, config, DefaultType), config
            }, _proto._handleSwipe = function() {
                var absDeltax = Math.abs(this.touchDeltaX);
                if (!(absDeltax <= 40)) {
                    var direction = absDeltax / this.touchDeltaX;
                    this.touchDeltaX = 0, direction > 0 && this.prev(), direction < 0 && this.next()
                }
            }, _proto._addEventListeners = function() {
                var _this3 = this;
                this._config.keyboard && EventHandler.on(this._element, "keydown.bs.carousel", (function(event) {
                    return _this3._keydown(event)
                })), "hover" === this._config.pause && (EventHandler.on(this._element, "mouseenter.bs.carousel", (function(event) {
                    return _this3.pause(event)
                })), EventHandler.on(this._element, "mouseleave.bs.carousel", (function(event) {
                    return _this3.cycle(event)
                }))), this._config.touch && this._touchSupported && this._addTouchEventListeners()
            }, _proto._addTouchEventListeners = function() {
                var _this4 = this,
                    start = function(event) {
                        _this4._pointerEvent && PointerType[event.pointerType.toUpperCase()] ? _this4.touchStartX = event.clientX : _this4._pointerEvent || (_this4.touchStartX = event.touches[0].clientX)
                    },
                    end = function(event) {
                        _this4._pointerEvent && PointerType[event.pointerType.toUpperCase()] && (_this4.touchDeltaX = event.clientX - _this4.touchStartX), _this4._handleSwipe(), "hover" === _this4._config.pause && (_this4.pause(), _this4.touchTimeout && clearTimeout(_this4.touchTimeout), _this4.touchTimeout = setTimeout((function(event) {
                            return _this4.cycle(event)
                        }), 500 + _this4._config.interval))
                    };
                SelectorEngine.find(".carousel-item img", this._element).forEach((function(itemImg) {
                    EventHandler.on(itemImg, "dragstart.bs.carousel", (function(e) {
                        return e.preventDefault()
                    }))
                })), this._pointerEvent ? (EventHandler.on(this._element, "pointerdown.bs.carousel", (function(event) {
                    return start(event)
                })), EventHandler.on(this._element, "pointerup.bs.carousel", (function(event) {
                    return end(event)
                })), this._element.classList.add("pointer-event")) : (EventHandler.on(this._element, "touchstart.bs.carousel", (function(event) {
                    return start(event)
                })), EventHandler.on(this._element, "touchmove.bs.carousel", (function(event) {
                    return function(event) {
                        event.touches && event.touches.length > 1 ? _this4.touchDeltaX = 0 : _this4.touchDeltaX = event.touches[0].clientX - _this4.touchStartX
                    }(event)
                })), EventHandler.on(this._element, "touchend.bs.carousel", (function(event) {
                    return end(event)
                })))
            }, _proto._keydown = function(event) {
                if (!/input|textarea/i.test(event.target.tagName)) switch (event.key) {
                    case "ArrowLeft":
                        event.preventDefault(), this.prev();
                        break;
                    case "ArrowRight":
                        event.preventDefault(), this.next()
                }
            }, _proto._getItemIndex = function(element) {
                return this._items = element && element.parentNode ? SelectorEngine.find(".carousel-item", element.parentNode) : [], this._items.indexOf(element)
            }, _proto._getItemByDirection = function(direction, activeElement) {
                var isNextDirection = "next" === direction,
                    isPrevDirection = "prev" === direction,
                    activeIndex = this._getItemIndex(activeElement),
                    lastItemIndex = this._items.length - 1;
                if ((isPrevDirection && 0 === activeIndex || isNextDirection && activeIndex === lastItemIndex) && !this._config.wrap) return activeElement;
                var itemIndex = (activeIndex + ("prev" === direction ? -1 : 1)) % this._items.length;
                return -1 === itemIndex ? this._items[this._items.length - 1] : this._items[itemIndex]
            }, _proto._triggerSlideEvent = function(relatedTarget, eventDirectionName) {
                var targetIndex = this._getItemIndex(relatedTarget),
                    fromIndex = this._getItemIndex(SelectorEngine.findOne(".active.carousel-item", this._element));
                return EventHandler.trigger(this._element, "slide.bs.carousel", {
                    relatedTarget: relatedTarget,
                    direction: eventDirectionName,
                    from: fromIndex,
                    to: targetIndex
                })
            }, _proto._setActiveIndicatorElement = function(element) {
                if (this._indicatorsElement) {
                    for (var indicators = SelectorEngine.find(".active", this._indicatorsElement), i = 0; i < indicators.length; i++) indicators[i].classList.remove("active");
                    var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
                    nextIndicator && nextIndicator.classList.add("active")
                }
            }, _proto._updateInterval = function() {
                var element = this._activeElement || SelectorEngine.findOne(".active.carousel-item", this._element);
                if (element) {
                    var elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
                    elementInterval ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = elementInterval) : this._config.interval = this._config.defaultInterval || this._config.interval
                }
            }, _proto._slide = function(direction, element) {
                var directionalClassName, orderClassName, eventDirectionName, _this5 = this,
                    activeElement = SelectorEngine.findOne(".active.carousel-item", this._element),
                    activeElementIndex = this._getItemIndex(activeElement),
                    nextElement = element || activeElement && this._getItemByDirection(direction, activeElement),
                    nextElementIndex = this._getItemIndex(nextElement),
                    isCycling = Boolean(this._interval);
                if ("next" === direction ? (directionalClassName = "carousel-item-start", orderClassName = "carousel-item-next", eventDirectionName = "left") : (directionalClassName = "carousel-item-end", orderClassName = "carousel-item-prev", eventDirectionName = "right"), nextElement && nextElement.classList.contains("active")) this._isSliding = !1;
                else if (!this._triggerSlideEvent(nextElement, eventDirectionName).defaultPrevented && activeElement && nextElement) {
                    if (this._isSliding = !0, isCycling && this.pause(), this._setActiveIndicatorElement(nextElement), this._activeElement = nextElement, this._element.classList.contains("slide")) {
                        nextElement.classList.add(orderClassName), reflow(nextElement), activeElement.classList.add(directionalClassName), nextElement.classList.add(directionalClassName);
                        var transitionDuration = getTransitionDurationFromElement(activeElement);
                        EventHandler.one(activeElement, "transitionend", (function() {
                            nextElement.classList.remove(directionalClassName, orderClassName), nextElement.classList.add("active"), activeElement.classList.remove("active", orderClassName, directionalClassName), _this5._isSliding = !1, setTimeout((function() {
                                EventHandler.trigger(_this5._element, "slid.bs.carousel", {
                                    relatedTarget: nextElement,
                                    direction: eventDirectionName,
                                    from: activeElementIndex,
                                    to: nextElementIndex
                                })
                            }), 0)
                        })), emulateTransitionEnd(activeElement, transitionDuration)
                    } else activeElement.classList.remove("active"), nextElement.classList.add("active"), this._isSliding = !1, EventHandler.trigger(this._element, "slid.bs.carousel", {
                        relatedTarget: nextElement,
                        direction: eventDirectionName,
                        from: activeElementIndex,
                        to: nextElementIndex
                    });
                    isCycling && this.cycle()
                }
            }, Carousel.carouselInterface = function(element, config) {
                var data = Data_getData(element, "bs.carousel"),
                    _config = _extends({}, Default, Manipulator.getDataAttributes(element));
                "object" == typeof config && (_config = _extends({}, _config, config));
                var action = "string" == typeof config ? config : _config.slide;
                if (data || (data = new Carousel(element, _config)), "number" == typeof config) data.to(config);
                else if ("string" == typeof action) {
                    if (void 0 === data[action]) throw new TypeError('No method named "' + action + '"');
                    data[action]()
                } else _config.interval && _config.ride && (data.pause(), data.cycle())
            }, Carousel.jQueryInterface = function(config) {
                return this.each((function() {
                    Carousel.carouselInterface(this, config)
                }))
            }, Carousel.dataApiClickHandler = function(event) {
                var target = getElementFromSelector(this);
                if (target && target.classList.contains("carousel")) {
                    var config = _extends({}, Manipulator.getDataAttributes(target), Manipulator.getDataAttributes(this)),
                        slideIndex = this.getAttribute("data-bs-slide-to");
                    slideIndex && (config.interval = !1), Carousel.carouselInterface(target, config), slideIndex && Data_getData(target, "bs.carousel").to(slideIndex), event.preventDefault()
                }
            }, _createClass(Carousel, null, [{
                key: "Default",
                get: function() {
                    return Default
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.carousel"
                }
            }]), Carousel
        }(BaseComponent);
    EventHandler.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Carousel.dataApiClickHandler), EventHandler.on(window, "load.bs.carousel.data-api", (function() {
        for (var carousels = SelectorEngine.find('[data-bs-ride="carousel"]'), i = 0, len = carousels.length; i < len; i++) Carousel.carouselInterface(carousels[i], Data_getData(carousels[i], "bs.carousel"))
    })), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn[NAME$2];
            $.fn[NAME$2] = Carousel.jQueryInterface, $.fn[NAME$2].Constructor = Carousel, $.fn[NAME$2].noConflict = function() {
                return $.fn[NAME$2] = JQUERY_NO_CONFLICT, Carousel.jQueryInterface
            }
        }
    }));
    var NAME$3 = "collapse",
        Default$1 = {
            toggle: !0,
            parent: ""
        },
        DefaultType$1 = {
            toggle: "boolean",
            parent: "(string|element)"
        },
        Collapse = function(_BaseComponent) {
            function Collapse(element, config) {
                var _this;
                (_this = _BaseComponent.call(this, element) || this)._isTransitioning = !1, _this._config = _this._getConfig(config), _this._triggerArray = SelectorEngine.find('[data-bs-toggle="collapse"][href="#' + element.id + '"],[data-bs-toggle="collapse"][data-bs-target="#' + element.id + '"]');
                for (var toggleList = SelectorEngine.find('[data-bs-toggle="collapse"]'), i = 0, len = toggleList.length; i < len; i++) {
                    var elem = toggleList[i],
                        selector = getSelectorFromElement(elem),
                        filterElement = SelectorEngine.find(selector).filter((function(foundElem) {
                            return foundElem === element
                        }));
                    null !== selector && filterElement.length && (_this._selector = selector, _this._triggerArray.push(elem))
                }
                return _this._parent = _this._config.parent ? _this._getParent() : null, _this._config.parent || _this._addAriaAndCollapsedClass(_this._element, _this._triggerArray), _this._config.toggle && _this.toggle(), _this
            }
            _inheritsLoose(Collapse, _BaseComponent);
            var _proto = Collapse.prototype;
            return _proto.toggle = function() {
                this._element.classList.contains("show") ? this.hide() : this.show()
            }, _proto.show = function() {
                var _this2 = this;
                if (!this._isTransitioning && !this._element.classList.contains("show")) {
                    var actives, activesData;
                    this._parent && 0 === (actives = SelectorEngine.find(".show, .collapsing", this._parent).filter((function(elem) {
                        return "string" == typeof _this2._config.parent ? elem.getAttribute("data-bs-parent") === _this2._config.parent : elem.classList.contains("collapse")
                    }))).length && (actives = null);
                    var container = SelectorEngine.findOne(this._selector);
                    if (actives) {
                        var tempActiveData = actives.find((function(elem) {
                            return container !== elem
                        }));
                        if ((activesData = tempActiveData ? Data_getData(tempActiveData, "bs.collapse") : null) && activesData._isTransitioning) return
                    }
                    if (!EventHandler.trigger(this._element, "show.bs.collapse").defaultPrevented) {
                        actives && actives.forEach((function(elemActive) {
                            container !== elemActive && Collapse.collapseInterface(elemActive, "hide"), activesData || Data_setData(elemActive, "bs.collapse", null)
                        }));
                        var dimension = this._getDimension();
                        this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[dimension] = 0, this._triggerArray.length && this._triggerArray.forEach((function(element) {
                            element.classList.remove("collapsed"), element.setAttribute("aria-expanded", !0)
                        })), this.setTransitioning(!0);
                        var scrollSize = "scroll" + (dimension[0].toUpperCase() + dimension.slice(1)),
                            transitionDuration = getTransitionDurationFromElement(this._element);
                        EventHandler.one(this._element, "transitionend", (function() {
                            _this2._element.classList.remove("collapsing"), _this2._element.classList.add("collapse", "show"), _this2._element.style[dimension] = "", _this2.setTransitioning(!1), EventHandler.trigger(_this2._element, "shown.bs.collapse")
                        })), emulateTransitionEnd(this._element, transitionDuration), this._element.style[dimension] = this._element[scrollSize] + "px"
                    }
                }
            }, _proto.hide = function() {
                var _this3 = this;
                if (!this._isTransitioning && this._element.classList.contains("show") && !EventHandler.trigger(this._element, "hide.bs.collapse").defaultPrevented) {
                    var dimension = this._getDimension();
                    this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px", reflow(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
                    var triggerArrayLength = this._triggerArray.length;
                    if (triggerArrayLength > 0)
                        for (var i = 0; i < triggerArrayLength; i++) {
                            var trigger = this._triggerArray[i],
                                elem = getElementFromSelector(trigger);
                            elem && !elem.classList.contains("show") && (trigger.classList.add("collapsed"), trigger.setAttribute("aria-expanded", !1))
                        }
                    this.setTransitioning(!0);
                    this._element.style[dimension] = "";
                    var transitionDuration = getTransitionDurationFromElement(this._element);
                    EventHandler.one(this._element, "transitionend", (function() {
                        _this3.setTransitioning(!1), _this3._element.classList.remove("collapsing"), _this3._element.classList.add("collapse"), EventHandler.trigger(_this3._element, "hidden.bs.collapse")
                    })), emulateTransitionEnd(this._element, transitionDuration)
                }
            }, _proto.setTransitioning = function(isTransitioning) {
                this._isTransitioning = isTransitioning
            }, _proto.dispose = function() {
                _BaseComponent.prototype.dispose.call(this), this._config = null, this._parent = null, this._triggerArray = null, this._isTransitioning = null
            }, _proto._getConfig = function(config) {
                return (config = _extends({}, Default$1, config)).toggle = Boolean(config.toggle), typeCheckConfig(NAME$3, config, DefaultType$1), config
            }, _proto._getDimension = function() {
                return this._element.classList.contains("width") ? "width" : "height"
            }, _proto._getParent = function() {
                var _this4 = this,
                    parent = this._config.parent;
                isElement(parent) ? void 0 === parent.jquery && void 0 === parent[0] || (parent = parent[0]) : parent = SelectorEngine.findOne(parent);
                var selector = '[data-bs-toggle="collapse"][data-bs-parent="' + parent + '"]';
                return SelectorEngine.find(selector, parent).forEach((function(element) {
                    var selected = getElementFromSelector(element);
                    _this4._addAriaAndCollapsedClass(selected, [element])
                })), parent
            }, _proto._addAriaAndCollapsedClass = function(element, triggerArray) {
                if (element && triggerArray.length) {
                    var isOpen = element.classList.contains("show");
                    triggerArray.forEach((function(elem) {
                        isOpen ? elem.classList.remove("collapsed") : elem.classList.add("collapsed"), elem.setAttribute("aria-expanded", isOpen)
                    }))
                }
            }, Collapse.collapseInterface = function(element, config) {
                var data = Data_getData(element, "bs.collapse"),
                    _config = _extends({}, Default$1, Manipulator.getDataAttributes(element), "object" == typeof config && config ? config : {});
                if (!data && _config.toggle && "string" == typeof config && /show|hide/.test(config) && (_config.toggle = !1), data || (data = new Collapse(element, _config)), "string" == typeof config) {
                    if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                    data[config]()
                }
            }, Collapse.jQueryInterface = function(config) {
                return this.each((function() {
                    Collapse.collapseInterface(this, config)
                }))
            }, _createClass(Collapse, null, [{
                key: "Default",
                get: function() {
                    return Default$1
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.collapse"
                }
            }]), Collapse
        }(BaseComponent);
    EventHandler.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function(event) {
        "A" === event.target.tagName && event.preventDefault();
        var triggerData = Manipulator.getDataAttributes(this),
            selector = getSelectorFromElement(this);
        SelectorEngine.find(selector).forEach((function(element) {
            var config, data = Data_getData(element, "bs.collapse");
            data ? (null === data._parent && "string" == typeof triggerData.parent && (data._config.parent = triggerData.parent, data._parent = data._getParent()), config = "toggle") : config = triggerData, Collapse.collapseInterface(element, config)
        }))
    })), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn[NAME$3];
            $.fn[NAME$3] = Collapse.jQueryInterface, $.fn[NAME$3].Constructor = Collapse, $.fn[NAME$3].noConflict = function() {
                return $.fn[NAME$3] = JQUERY_NO_CONFLICT, Collapse.jQueryInterface
            }
        }
    }));
    var top = "top",
        bottom = "bottom",
        right = "right",
        left = "left",
        auto = "auto",
        basePlacements = [top, bottom, right, left],
        start = "start",
        end = "end",
        clippingParents = "clippingParents",
        viewport = "viewport",
        popper = "popper",
        reference = "reference",
        variationPlacements = basePlacements.reduce((function(acc, placement) {
            return acc.concat([placement + "-" + start, placement + "-" + end])
        }), []),
        placements = [].concat(basePlacements, [auto]).reduce((function(acc, placement) {
            return acc.concat([placement, placement + "-" + start, placement + "-" + end])
        }), []),
        modifierPhases = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

    function getNodeName(element) {
        return element ? (element.nodeName || "").toLowerCase() : null
    }

    function getWindow(node) {
        if ("[object Window]" !== node.toString()) {
            var ownerDocument = node.ownerDocument;
            return ownerDocument && ownerDocument.defaultView || window
        }
        return node
    }

    function isElement$1(node) {
        return node instanceof getWindow(node).Element || node instanceof Element
    }

    function isHTMLElement(node) {
        return node instanceof getWindow(node).HTMLElement || node instanceof HTMLElement
    }
    var applyStyles$1 = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: function(_ref) {
            var state = _ref.state;
            Object.keys(state.elements).forEach((function(name) {
                var style = state.styles[name] || {},
                    attributes = state.attributes[name] || {},
                    element = state.elements[name];
                isHTMLElement(element) && getNodeName(element) && (Object.assign(element.style, style), Object.keys(attributes).forEach((function(name) {
                    var value = attributes[name];
                    !1 === value ? element.removeAttribute(name) : element.setAttribute(name, !0 === value ? "" : value)
                })))
            }))
        },
        effect: function(_ref2) {
            var state = _ref2.state,
                initialStyles = {
                    popper: {
                        position: state.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
            return Object.assign(state.elements.popper.style, initialStyles.popper), state.elements.arrow && Object.assign(state.elements.arrow.style, initialStyles.arrow),
                function() {
                    Object.keys(state.elements).forEach((function(name) {
                        var element = state.elements[name],
                            attributes = state.attributes[name] || {},
                            style = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]).reduce((function(style, property) {
                                return style[property] = "", style
                            }), {});
                        isHTMLElement(element) && getNodeName(element) && (Object.assign(element.style, style), Object.keys(attributes).forEach((function(attribute) {
                            element.removeAttribute(attribute)
                        })))
                    }))
                }
        },
        requires: ["computeStyles"]
    };

    function getBasePlacement(placement) {
        return placement.split("-")[0]
    }

    function getLayoutRect(element) {
        return {
            x: element.offsetLeft,
            y: element.offsetTop,
            width: element.offsetWidth,
            height: element.offsetHeight
        }
    }

    function contains(parent, child) {
        var node, rootNode = child.getRootNode && child.getRootNode();
        if (parent.contains(child)) return !0;
        if (rootNode && ((node = rootNode) instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot)) {
            var next = child;
            do {
                if (next && parent.isSameNode(next)) return !0;
                next = next.parentNode || next.host
            } while (next)
        }
        return !1
    }

    function getComputedStyle$1(element) {
        return getWindow(element).getComputedStyle(element)
    }

    function isTableElement(element) {
        return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0
    }

    function getDocumentElement(element) {
        return ((isElement$1(element) ? element.ownerDocument : element.document) || window.document).documentElement
    }

    function getParentNode(element) {
        return "html" === getNodeName(element) ? element : element.assignedSlot || element.parentNode || element.host || getDocumentElement(element)
    }

    function getTrueOffsetParent(element) {
        if (!isHTMLElement(element) || "fixed" === getComputedStyle$1(element).position) return null;
        var offsetParent = element.offsetParent;
        if (offsetParent) {
            var html = getDocumentElement(offsetParent);
            if ("body" === getNodeName(offsetParent) && "static" === getComputedStyle$1(offsetParent).position && "static" !== getComputedStyle$1(html).position) return html
        }
        return offsetParent
    }

    function getOffsetParent(element) {
        for (var window = getWindow(element), offsetParent = getTrueOffsetParent(element); offsetParent && isTableElement(offsetParent) && "static" === getComputedStyle$1(offsetParent).position;) offsetParent = getTrueOffsetParent(offsetParent);
        return offsetParent && "body" === getNodeName(offsetParent) && "static" === getComputedStyle$1(offsetParent).position ? window : offsetParent || function(element) {
            for (var currentNode = getParentNode(element); isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0;) {
                var css = getComputedStyle$1(currentNode);
                if ("none" !== css.transform || "none" !== css.perspective || css.willChange && "auto" !== css.willChange) return currentNode;
                currentNode = currentNode.parentNode
            }
            return null
        }(element) || window
    }

    function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y"
    }

    function within(min, value, max) {
        return Math.max(min, Math.min(value, max))
    }

    function mergePaddingObject(paddingObject) {
        return Object.assign(Object.assign({}, {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }), paddingObject)
    }

    function expandToHashMap(value, keys) {
        return keys.reduce((function(hashMap, key) {
            return hashMap[key] = value, hashMap
        }), {})
    }
    var arrow$1 = {
            name: "arrow",
            enabled: !0,
            phase: "main",
            fn: function(_ref) {
                var _state$modifiersData$, state = _ref.state,
                    name = _ref.name,
                    arrowElement = state.elements.arrow,
                    popperOffsets = state.modifiersData.popperOffsets,
                    basePlacement = getBasePlacement(state.placement),
                    axis = getMainAxisFromPlacement(basePlacement),
                    len = [left, right].indexOf(basePlacement) >= 0 ? "height" : "width";
                if (arrowElement && popperOffsets) {
                    var paddingObject = state.modifiersData[name + "#persistent"].padding,
                        arrowRect = getLayoutRect(arrowElement),
                        minProp = "y" === axis ? top : left,
                        maxProp = "y" === axis ? bottom : right,
                        endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len],
                        startDiff = popperOffsets[axis] - state.rects.reference[axis],
                        arrowOffsetParent = getOffsetParent(arrowElement),
                        clientSize = arrowOffsetParent ? "y" === axis ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0,
                        centerToReference = endDiff / 2 - startDiff / 2,
                        min = paddingObject[minProp],
                        max = clientSize - arrowRect[len] - paddingObject[maxProp],
                        center = clientSize / 2 - arrowRect[len] / 2 + centerToReference,
                        offset = within(min, center, max),
                        axisProp = axis;
                    state.modifiersData[name] = ((_state$modifiersData$ = {})[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$)
                }
            },
            effect: function(_ref2) {
                var state = _ref2.state,
                    options = _ref2.options,
                    name = _ref2.name,
                    _options$element = options.element,
                    arrowElement = void 0 === _options$element ? "[data-popper-arrow]" : _options$element,
                    _options$padding = options.padding,
                    padding = void 0 === _options$padding ? 0 : _options$padding;
                null != arrowElement && ("string" != typeof arrowElement || (arrowElement = state.elements.popper.querySelector(arrowElement))) && contains(state.elements.popper, arrowElement) && (state.elements.arrow = arrowElement, state.modifiersData[name + "#persistent"] = {
                    padding: mergePaddingObject("number" != typeof padding ? padding : expandToHashMap(padding, basePlacements))
                })
            },
            requires: ["popperOffsets"],
            requiresIfExists: ["preventOverflow"]
        },
        unsetSides = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };

    function mapToStyles(_ref2) {
        var _Object$assign2, popper = _ref2.popper,
            popperRect = _ref2.popperRect,
            placement = _ref2.placement,
            offsets = _ref2.offsets,
            position = _ref2.position,
            gpuAcceleration = _ref2.gpuAcceleration,
            adaptive = _ref2.adaptive,
            _roundOffsets = function(_ref) {
                var x = _ref.x,
                    y = _ref.y,
                    dpr = window.devicePixelRatio || 1;
                return {
                    x: Math.round(x * dpr) / dpr || 0,
                    y: Math.round(y * dpr) / dpr || 0
                }
            }(offsets),
            x = _roundOffsets.x,
            y = _roundOffsets.y,
            hasX = offsets.hasOwnProperty("x"),
            hasY = offsets.hasOwnProperty("y"),
            sideX = left,
            sideY = top,
            win = window;
        if (adaptive) {
            var offsetParent = getOffsetParent(popper);
            offsetParent === getWindow(popper) && (offsetParent = getDocumentElement(popper)), placement === top && (sideY = bottom, y -= offsetParent.clientHeight - popperRect.height, y *= gpuAcceleration ? 1 : -1), placement === left && (sideX = right, x -= offsetParent.clientWidth - popperRect.width, x *= gpuAcceleration ? 1 : -1)
        }
        var _Object$assign, commonStyles = Object.assign({
            position: position
        }, adaptive && unsetSides);
        return gpuAcceleration ? Object.assign(Object.assign({}, commonStyles), {}, ((_Object$assign = {})[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign)) : Object.assign(Object.assign({}, commonStyles), {}, ((_Object$assign2 = {})[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2))
    }
    var computeStyles$1 = {
            name: "computeStyles",
            enabled: !0,
            phase: "beforeWrite",
            fn: function(_ref3) {
                var state = _ref3.state,
                    options = _ref3.options,
                    _options$gpuAccelerat = options.gpuAcceleration,
                    gpuAcceleration = void 0 === _options$gpuAccelerat || _options$gpuAccelerat,
                    _options$adaptive = options.adaptive,
                    adaptive = void 0 === _options$adaptive || _options$adaptive,
                    commonStyles = {
                        placement: getBasePlacement(state.placement),
                        popper: state.elements.popper,
                        popperRect: state.rects.popper,
                        gpuAcceleration: gpuAcceleration
                    };
                null != state.modifiersData.popperOffsets && (state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
                    offsets: state.modifiersData.popperOffsets,
                    position: state.options.strategy,
                    adaptive: adaptive
                })))), null != state.modifiersData.arrow && (state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
                    offsets: state.modifiersData.arrow,
                    position: "absolute",
                    adaptive: !1
                })))), state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
                    "data-popper-placement": state.placement
                })
            },
            data: {}
        },
        passive = {
            passive: !0
        };
    var eventListeners = {
            name: "eventListeners",
            enabled: !0,
            phase: "write",
            fn: function() {},
            effect: function(_ref) {
                var state = _ref.state,
                    instance = _ref.instance,
                    options = _ref.options,
                    _options$scroll = options.scroll,
                    scroll = void 0 === _options$scroll || _options$scroll,
                    _options$resize = options.resize,
                    resize = void 0 === _options$resize || _options$resize,
                    window = getWindow(state.elements.popper),
                    scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
                return scroll && scrollParents.forEach((function(scrollParent) {
                        scrollParent.addEventListener("scroll", instance.update, passive)
                    })), resize && window.addEventListener("resize", instance.update, passive),
                    function() {
                        scroll && scrollParents.forEach((function(scrollParent) {
                            scrollParent.removeEventListener("scroll", instance.update, passive)
                        })), resize && window.removeEventListener("resize", instance.update, passive)
                    }
            },
            data: {}
        },
        hash = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };

    function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, (function(matched) {
            return hash[matched]
        }))
    }
    var hash$1 = {
        start: "end",
        end: "start"
    };

    function getOppositeVariationPlacement(placement) {
        return placement.replace(/start|end/g, (function(matched) {
            return hash$1[matched]
        }))
    }

    function getBoundingClientRect(element) {
        var rect = element.getBoundingClientRect();
        return {
            width: rect.width,
            height: rect.height,
            top: rect.top,
            right: rect.right,
            bottom: rect.bottom,
            left: rect.left,
            x: rect.left,
            y: rect.top
        }
    }

    function getWindowScroll(node) {
        var win = getWindow(node);
        return {
            scrollLeft: win.pageXOffset,
            scrollTop: win.pageYOffset
        }
    }

    function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft
    }

    function isScrollParent(element) {
        var _getComputedStyle = getComputedStyle$1(element),
            overflow = _getComputedStyle.overflow,
            overflowX = _getComputedStyle.overflowX,
            overflowY = _getComputedStyle.overflowY;
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)
    }

    function getScrollParent(node) {
        return ["html", "body", "#document"].indexOf(getNodeName(node)) >= 0 ? node.ownerDocument.body : isHTMLElement(node) && isScrollParent(node) ? node : getScrollParent(getParentNode(node))
    }

    function listScrollParents(element, list) {
        void 0 === list && (list = []);
        var scrollParent = getScrollParent(element),
            isBody = "body" === getNodeName(scrollParent),
            win = getWindow(scrollParent),
            target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent,
            updatedList = list.concat(target);
        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)))
    }

    function rectToClientRect(rect) {
        return Object.assign(Object.assign({}, rect), {}, {
            left: rect.x,
            top: rect.y,
            right: rect.x + rect.width,
            bottom: rect.y + rect.height
        })
    }

    function getClientRectFromMixedType(element, clippingParent) {
        return clippingParent === viewport ? rectToClientRect(function(element) {
            var win = getWindow(element),
                html = getDocumentElement(element),
                visualViewport = win.visualViewport,
                width = html.clientWidth,
                height = html.clientHeight,
                x = 0,
                y = 0;
            return visualViewport && (width = visualViewport.width, height = visualViewport.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (x = visualViewport.offsetLeft, y = visualViewport.offsetTop)), {
                width: width,
                height: height,
                x: x + getWindowScrollBarX(element),
                y: y
            }
        }(element)) : isHTMLElement(clippingParent) ? function(element) {
            var rect = getBoundingClientRect(element);
            return rect.top = rect.top + element.clientTop, rect.left = rect.left + element.clientLeft, rect.bottom = rect.top + element.clientHeight, rect.right = rect.left + element.clientWidth, rect.width = element.clientWidth, rect.height = element.clientHeight, rect.x = rect.left, rect.y = rect.top, rect
        }(clippingParent) : rectToClientRect(function(element) {
            var html = getDocumentElement(element),
                winScroll = getWindowScroll(element),
                body = element.ownerDocument.body,
                width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0),
                height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0),
                x = -winScroll.scrollLeft + getWindowScrollBarX(element),
                y = -winScroll.scrollTop;
            return "rtl" === getComputedStyle$1(body || html).direction && (x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width), {
                width: width,
                height: height,
                x: x,
                y: y
            }
        }(getDocumentElement(element)))
    }

    function getClippingRect(element, boundary, rootBoundary) {
        var mainClippingParents = "clippingParents" === boundary ? function(element) {
                var clippingParents = listScrollParents(getParentNode(element)),
                    clipperElement = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0 && isHTMLElement(element) ? getOffsetParent(element) : element;
                return isElement$1(clipperElement) ? clippingParents.filter((function(clippingParent) {
                    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && "body" !== getNodeName(clippingParent)
                })) : []
            }(element) : [].concat(boundary),
            clippingParents = [].concat(mainClippingParents, [rootBoundary]),
            firstClippingParent = clippingParents[0],
            clippingRect = clippingParents.reduce((function(accRect, clippingParent) {
                var rect = getClientRectFromMixedType(element, clippingParent);
                return accRect.top = Math.max(rect.top, accRect.top), accRect.right = Math.min(rect.right, accRect.right), accRect.bottom = Math.min(rect.bottom, accRect.bottom), accRect.left = Math.max(rect.left, accRect.left), accRect
            }), getClientRectFromMixedType(element, firstClippingParent));
        return clippingRect.width = clippingRect.right - clippingRect.left, clippingRect.height = clippingRect.bottom - clippingRect.top, clippingRect.x = clippingRect.left, clippingRect.y = clippingRect.top, clippingRect
    }

    function getVariation(placement) {
        return placement.split("-")[1]
    }

    function computeOffsets(_ref) {
        var offsets, reference = _ref.reference,
            element = _ref.element,
            placement = _ref.placement,
            basePlacement = placement ? getBasePlacement(placement) : null,
            variation = placement ? getVariation(placement) : null,
            commonX = reference.x + reference.width / 2 - element.width / 2,
            commonY = reference.y + reference.height / 2 - element.height / 2;
        switch (basePlacement) {
            case top:
                offsets = {
                    x: commonX,
                    y: reference.y - element.height
                };
                break;
            case bottom:
                offsets = {
                    x: commonX,
                    y: reference.y + reference.height
                };
                break;
            case right:
                offsets = {
                    x: reference.x + reference.width,
                    y: commonY
                };
                break;
            case left:
                offsets = {
                    x: reference.x - element.width,
                    y: commonY
                };
                break;
            default:
                offsets = {
                    x: reference.x,
                    y: reference.y
                }
        }
        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
        if (null != mainAxis) {
            var len = "y" === mainAxis ? "height" : "width";
            switch (variation) {
                case start:
                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
                    break;
                case end:
                    offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2)
            }
        }
        return offsets
    }

    function detectOverflow(state, options) {
        void 0 === options && (options = {});
        var _options = options,
            _options$placement = _options.placement,
            placement = void 0 === _options$placement ? state.placement : _options$placement,
            _options$boundary = _options.boundary,
            boundary = void 0 === _options$boundary ? clippingParents : _options$boundary,
            _options$rootBoundary = _options.rootBoundary,
            rootBoundary = void 0 === _options$rootBoundary ? viewport : _options$rootBoundary,
            _options$elementConte = _options.elementContext,
            elementContext = void 0 === _options$elementConte ? popper : _options$elementConte,
            _options$altBoundary = _options.altBoundary,
            altBoundary = void 0 !== _options$altBoundary && _options$altBoundary,
            _options$padding = _options.padding,
            padding = void 0 === _options$padding ? 0 : _options$padding,
            paddingObject = mergePaddingObject("number" != typeof padding ? padding : expandToHashMap(padding, basePlacements)),
            altContext = elementContext === popper ? reference : popper,
            referenceElement = state.elements.reference,
            popperRect = state.rects.popper,
            element = state.elements[altBoundary ? altContext : elementContext],
            clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary),
            referenceClientRect = getBoundingClientRect(referenceElement),
            popperOffsets = computeOffsets({
                reference: referenceClientRect,
                element: popperRect,
                strategy: "absolute",
                placement: placement
            }),
            popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets)),
            elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect,
            overflowOffsets = {
                top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
                bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
                left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
                right: elementClientRect.right - clippingClientRect.right + paddingObject.right
            },
            offsetData = state.modifiersData.offset;
        if (elementContext === popper && offsetData) {
            var offset = offsetData[placement];
            Object.keys(overflowOffsets).forEach((function(key) {
                var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1,
                    axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
                overflowOffsets[key] += offset[axis] * multiply
            }))
        }
        return overflowOffsets
    }

    function computeAutoPlacement(state, options) {
        void 0 === options && (options = {});
        var _options = options,
            placement = _options.placement,
            boundary = _options.boundary,
            rootBoundary = _options.rootBoundary,
            padding = _options.padding,
            flipVariations = _options.flipVariations,
            _options$allowedAutoP = _options.allowedAutoPlacements,
            allowedAutoPlacements = void 0 === _options$allowedAutoP ? placements : _options$allowedAutoP,
            variation = getVariation(placement),
            placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter((function(placement) {
                return getVariation(placement) === variation
            })) : basePlacements,
            allowedPlacements = placements$1.filter((function(placement) {
                return allowedAutoPlacements.indexOf(placement) >= 0
            }));
        0 === allowedPlacements.length && (allowedPlacements = placements$1);
        var overflows = allowedPlacements.reduce((function(acc, placement) {
            return acc[placement] = detectOverflow(state, {
                placement: placement,
                boundary: boundary,
                rootBoundary: rootBoundary,
                padding: padding
            })[getBasePlacement(placement)], acc
        }), {});
        return Object.keys(overflows).sort((function(a, b) {
            return overflows[a] - overflows[b]
        }))
    }
    var flip$1 = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function(_ref) {
            var state = _ref.state,
                options = _ref.options,
                name = _ref.name;
            if (!state.modifiersData[name]._skip) {
                for (var _options$mainAxis = options.mainAxis, checkMainAxis = void 0 === _options$mainAxis || _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = void 0 === _options$altAxis || _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = void 0 === _options$flipVariatio || _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements, preferredPlacement = state.options.placement, basePlacement = getBasePlacement(preferredPlacement), fallbackPlacements = specifiedFallbackPlacements || (basePlacement === preferredPlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : function(placement) {
                        if (getBasePlacement(placement) === auto) return [];
                        var oppositePlacement = getOppositePlacement(placement);
                        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)]
                    }(preferredPlacement)), placements = [preferredPlacement].concat(fallbackPlacements).reduce((function(acc, placement) {
                        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
                            placement: placement,
                            boundary: boundary,
                            rootBoundary: rootBoundary,
                            padding: padding,
                            flipVariations: flipVariations,
                            allowedAutoPlacements: allowedAutoPlacements
                        }) : placement)
                    }), []), referenceRect = state.rects.reference, popperRect = state.rects.popper, checksMap = new Map, makeFallbackChecks = !0, firstFittingPlacement = placements[0], i = 0; i < placements.length; i++) {
                    var placement = placements[i],
                        _basePlacement = getBasePlacement(placement),
                        isStartVariation = getVariation(placement) === start,
                        isVertical = [top, bottom].indexOf(_basePlacement) >= 0,
                        len = isVertical ? "width" : "height",
                        overflow = detectOverflow(state, {
                            placement: placement,
                            boundary: boundary,
                            rootBoundary: rootBoundary,
                            altBoundary: altBoundary,
                            padding: padding
                        }),
                        mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
                    referenceRect[len] > popperRect[len] && (mainVariationSide = getOppositePlacement(mainVariationSide));
                    var altVariationSide = getOppositePlacement(mainVariationSide),
                        checks = [];
                    if (checkMainAxis && checks.push(overflow[_basePlacement] <= 0), checkAltAxis && checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0), checks.every((function(check) {
                            return check
                        }))) {
                        firstFittingPlacement = placement, makeFallbackChecks = !1;
                        break
                    }
                    checksMap.set(placement, checks)
                }
                if (makeFallbackChecks)
                    for (var _loop = function(_i) {
                            var fittingPlacement = placements.find((function(placement) {
                                var checks = checksMap.get(placement);
                                if (checks) return checks.slice(0, _i).every((function(check) {
                                    return check
                                }))
                            }));
                            if (fittingPlacement) return firstFittingPlacement = fittingPlacement, "break"
                        }, _i = flipVariations ? 3 : 1; _i > 0; _i--) {
                        if ("break" === _loop(_i)) break
                    }
                state.placement !== firstFittingPlacement && (state.modifiersData[name]._skip = !0, state.placement = firstFittingPlacement, state.reset = !0)
            }
        },
        requiresIfExists: ["offset"],
        data: {
            _skip: !1
        }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
        return void 0 === preventedOffsets && (preventedOffsets = {
            x: 0,
            y: 0
        }), {
            top: overflow.top - rect.height - preventedOffsets.y,
            right: overflow.right - rect.width + preventedOffsets.x,
            bottom: overflow.bottom - rect.height + preventedOffsets.y,
            left: overflow.left - rect.width - preventedOffsets.x
        }
    }

    function isAnySideFullyClipped(overflow) {
        return [top, right, bottom, left].some((function(side) {
            return overflow[side] >= 0
        }))
    }
    var hide$1 = {
        name: "hide",
        enabled: !0,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: function(_ref) {
            var state = _ref.state,
                name = _ref.name,
                referenceRect = state.rects.reference,
                popperRect = state.rects.popper,
                preventedOffsets = state.modifiersData.preventOverflow,
                referenceOverflow = detectOverflow(state, {
                    elementContext: "reference"
                }),
                popperAltOverflow = detectOverflow(state, {
                    altBoundary: !0
                }),
                referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect),
                popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets),
                isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets),
                hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
            state.modifiersData[name] = {
                referenceClippingOffsets: referenceClippingOffsets,
                popperEscapeOffsets: popperEscapeOffsets,
                isReferenceHidden: isReferenceHidden,
                hasPopperEscaped: hasPopperEscaped
            }, state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
                "data-popper-reference-hidden": isReferenceHidden,
                "data-popper-escaped": hasPopperEscaped
            })
        }
    };
    var offset$1 = {
        name: "offset",
        enabled: !0,
        phase: "main",
        requires: ["popperOffsets"],
        fn: function(_ref2) {
            var state = _ref2.state,
                options = _ref2.options,
                name = _ref2.name,
                _options$offset = options.offset,
                offset = void 0 === _options$offset ? [0, 0] : _options$offset,
                data = placements.reduce((function(acc, placement) {
                    return acc[placement] = function(placement, rects, offset) {
                        var basePlacement = getBasePlacement(placement),
                            invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1,
                            _ref = "function" == typeof offset ? offset(Object.assign(Object.assign({}, rects), {}, {
                                placement: placement
                            })) : offset,
                            skidding = _ref[0],
                            distance = _ref[1];
                        return skidding = skidding || 0, distance = (distance || 0) * invertDistance, [left, right].indexOf(basePlacement) >= 0 ? {
                            x: distance,
                            y: skidding
                        } : {
                            x: skidding,
                            y: distance
                        }
                    }(placement, state.rects, offset), acc
                }), {}),
                _data$state$placement = data[state.placement],
                x = _data$state$placement.x,
                y = _data$state$placement.y;
            null != state.modifiersData.popperOffsets && (state.modifiersData.popperOffsets.x += x, state.modifiersData.popperOffsets.y += y), state.modifiersData[name] = data
        }
    };
    var popperOffsets$1 = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function(_ref) {
            var state = _ref.state,
                name = _ref.name;
            state.modifiersData[name] = computeOffsets({
                reference: state.rects.reference,
                element: state.rects.popper,
                strategy: "absolute",
                placement: state.placement
            })
        },
        data: {}
    };
    var preventOverflow$1 = {
        name: "preventOverflow",
        enabled: !0,
        phase: "main",
        fn: function(_ref) {
            var state = _ref.state,
                options = _ref.options,
                name = _ref.name,
                _options$mainAxis = options.mainAxis,
                checkMainAxis = void 0 === _options$mainAxis || _options$mainAxis,
                _options$altAxis = options.altAxis,
                checkAltAxis = void 0 !== _options$altAxis && _options$altAxis,
                boundary = options.boundary,
                rootBoundary = options.rootBoundary,
                altBoundary = options.altBoundary,
                padding = options.padding,
                _options$tether = options.tether,
                tether = void 0 === _options$tether || _options$tether,
                _options$tetherOffset = options.tetherOffset,
                tetherOffset = void 0 === _options$tetherOffset ? 0 : _options$tetherOffset,
                overflow = detectOverflow(state, {
                    boundary: boundary,
                    rootBoundary: rootBoundary,
                    padding: padding,
                    altBoundary: altBoundary
                }),
                basePlacement = getBasePlacement(state.placement),
                variation = getVariation(state.placement),
                isBasePlacement = !variation,
                mainAxis = getMainAxisFromPlacement(basePlacement),
                altAxis = "x" === mainAxis ? "y" : "x",
                popperOffsets = state.modifiersData.popperOffsets,
                referenceRect = state.rects.reference,
                popperRect = state.rects.popper,
                tetherOffsetValue = "function" == typeof tetherOffset ? tetherOffset(Object.assign(Object.assign({}, state.rects), {}, {
                    placement: state.placement
                })) : tetherOffset,
                data = {
                    x: 0,
                    y: 0
                };
            if (popperOffsets) {
                if (checkMainAxis) {
                    var mainSide = "y" === mainAxis ? top : left,
                        altSide = "y" === mainAxis ? bottom : right,
                        len = "y" === mainAxis ? "height" : "width",
                        offset = popperOffsets[mainAxis],
                        min = popperOffsets[mainAxis] + overflow[mainSide],
                        max = popperOffsets[mainAxis] - overflow[altSide],
                        additive = tether ? -popperRect[len] / 2 : 0,
                        minLen = variation === start ? referenceRect[len] : popperRect[len],
                        maxLen = variation === start ? -popperRect[len] : -referenceRect[len],
                        arrowElement = state.elements.arrow,
                        arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                            width: 0,
                            height: 0
                        },
                        arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        },
                        arrowPaddingMin = arrowPaddingObject[mainSide],
                        arrowPaddingMax = arrowPaddingObject[altSide],
                        arrowLen = within(0, referenceRect[len], arrowRect[len]),
                        minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue,
                        maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue,
                        arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow),
                        clientOffset = arrowOffsetParent ? "y" === mainAxis ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0,
                        offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0,
                        tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset,
                        tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue,
                        preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
                    popperOffsets[mainAxis] = preventedOffset, data[mainAxis] = preventedOffset - offset
                }
                if (checkAltAxis) {
                    var _mainSide = "x" === mainAxis ? top : left,
                        _altSide = "x" === mainAxis ? bottom : right,
                        _offset = popperOffsets[altAxis],
                        _preventedOffset = within(_offset + overflow[_mainSide], _offset, _offset - overflow[_altSide]);
                    popperOffsets[altAxis] = _preventedOffset, data[altAxis] = _preventedOffset - _offset
                }
                state.modifiersData[name] = data
            }
        },
        requiresIfExists: ["offset"]
    };

    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
        void 0 === isFixed && (isFixed = !1);
        var node, element, documentElement = getDocumentElement(offsetParent),
            rect = getBoundingClientRect(elementOrVirtualElement),
            isOffsetParentAnElement = isHTMLElement(offsetParent),
            scroll = {
                scrollLeft: 0,
                scrollTop: 0
            },
            offsets = {
                x: 0,
                y: 0
            };
        return (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && (("body" !== getNodeName(offsetParent) || isScrollParent(documentElement)) && (scroll = (node = offsetParent) !== getWindow(node) && isHTMLElement(node) ? {
            scrollLeft: (element = node).scrollLeft,
            scrollTop: element.scrollTop
        } : getWindowScroll(node)), isHTMLElement(offsetParent) ? ((offsets = getBoundingClientRect(offsetParent)).x += offsetParent.clientLeft, offsets.y += offsetParent.clientTop) : documentElement && (offsets.x = getWindowScrollBarX(documentElement))), {
            x: rect.left + scroll.scrollLeft - offsets.x,
            y: rect.top + scroll.scrollTop - offsets.y,
            width: rect.width,
            height: rect.height
        }
    }

    function order(modifiers) {
        var map = new Map,
            visited = new Set,
            result = [];

        function sort(modifier) {
            visited.add(modifier.name), [].concat(modifier.requires || [], modifier.requiresIfExists || []).forEach((function(dep) {
                if (!visited.has(dep)) {
                    var depModifier = map.get(dep);
                    depModifier && sort(depModifier)
                }
            })), result.push(modifier)
        }
        return modifiers.forEach((function(modifier) {
            map.set(modifier.name, modifier)
        })), modifiers.forEach((function(modifier) {
            visited.has(modifier.name) || sort(modifier)
        })), result
    }
    var DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };

    function areValidElements() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return !args.some((function(element) {
            return !(element && "function" == typeof element.getBoundingClientRect)
        }))
    }

    function popperGenerator(generatorOptions) {
        void 0 === generatorOptions && (generatorOptions = {});
        var _generatorOptions = generatorOptions,
            _generatorOptions$def = _generatorOptions.defaultModifiers,
            defaultModifiers = void 0 === _generatorOptions$def ? [] : _generatorOptions$def,
            _generatorOptions$def2 = _generatorOptions.defaultOptions,
            defaultOptions = void 0 === _generatorOptions$def2 ? DEFAULT_OPTIONS : _generatorOptions$def2;
        return function(reference, popper, options) {
            void 0 === options && (options = defaultOptions);
            var fn, pending, state = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
                    modifiersData: {},
                    elements: {
                        reference: reference,
                        popper: popper
                    },
                    attributes: {},
                    styles: {}
                },
                effectCleanupFns = [],
                isDestroyed = !1,
                instance = {
                    state: state,
                    setOptions: function(options) {
                        cleanupModifierEffects(), state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options), state.scrollParents = {
                            reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                            popper: listScrollParents(popper)
                        };
                        var modifiers, merged, orderedModifiers = function(modifiers) {
                            var orderedModifiers = order(modifiers);
                            return modifierPhases.reduce((function(acc, phase) {
                                return acc.concat(orderedModifiers.filter((function(modifier) {
                                    return modifier.phase === phase
                                })))
                            }), [])
                        }((modifiers = [].concat(defaultModifiers, state.options.modifiers), merged = modifiers.reduce((function(merged, current) {
                            var existing = merged[current.name];
                            return merged[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {}, {
                                options: Object.assign(Object.assign({}, existing.options), current.options),
                                data: Object.assign(Object.assign({}, existing.data), current.data)
                            }) : current, merged
                        }), {}), Object.keys(merged).map((function(key) {
                            return merged[key]
                        }))));
                        return state.orderedModifiers = orderedModifiers.filter((function(m) {
                            return m.enabled
                        })), state.orderedModifiers.forEach((function(_ref3) {
                            var name = _ref3.name,
                                _ref3$options = _ref3.options,
                                options = void 0 === _ref3$options ? {} : _ref3$options,
                                effect = _ref3.effect;
                            if ("function" == typeof effect) {
                                var cleanupFn = effect({
                                        state: state,
                                        name: name,
                                        instance: instance,
                                        options: options
                                    }),
                                    noopFn = function() {};
                                effectCleanupFns.push(cleanupFn || noopFn)
                            }
                        })), instance.update()
                    },
                    forceUpdate: function() {
                        if (!isDestroyed) {
                            var _state$elements = state.elements,
                                reference = _state$elements.reference,
                                popper = _state$elements.popper;
                            if (areValidElements(reference, popper)) {
                                state.rects = {
                                    reference: getCompositeRect(reference, getOffsetParent(popper), "fixed" === state.options.strategy),
                                    popper: getLayoutRect(popper)
                                }, state.reset = !1, state.placement = state.options.placement, state.orderedModifiers.forEach((function(modifier) {
                                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data)
                                }));
                                for (var index = 0; index < state.orderedModifiers.length; index++)
                                    if (!0 !== state.reset) {
                                        var _state$orderedModifie = state.orderedModifiers[index],
                                            fn = _state$orderedModifie.fn,
                                            _state$orderedModifie2 = _state$orderedModifie.options,
                                            _options = void 0 === _state$orderedModifie2 ? {} : _state$orderedModifie2,
                                            name = _state$orderedModifie.name;
                                        "function" == typeof fn && (state = fn({
                                            state: state,
                                            options: _options,
                                            name: name,
                                            instance: instance
                                        }) || state)
                                    } else state.reset = !1, index = -1
                            }
                        }
                    },
                    update: (fn = function() {
                        return new Promise((function(resolve) {
                            instance.forceUpdate(), resolve(state)
                        }))
                    }, function() {
                        return pending || (pending = new Promise((function(resolve) {
                            Promise.resolve().then((function() {
                                pending = void 0, resolve(fn())
                            }))
                        }))), pending
                    }),
                    destroy: function() {
                        cleanupModifierEffects(), isDestroyed = !0
                    }
                };
            if (!areValidElements(reference, popper)) return instance;

            function cleanupModifierEffects() {
                effectCleanupFns.forEach((function(fn) {
                    return fn()
                })), effectCleanupFns = []
            }
            return instance.setOptions(options).then((function(state) {
                !isDestroyed && options.onFirstUpdate && options.onFirstUpdate(state)
            })), instance
        }
    }
    var createPopper = popperGenerator(),
        createPopper$1 = popperGenerator({
            defaultModifiers: [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1]
        }),
        createPopper$2 = popperGenerator({
            defaultModifiers: [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1]
        }),
        Popper = Object.freeze({
            __proto__: null,
            popperGenerator: popperGenerator,
            detectOverflow: detectOverflow,
            createPopperBase: createPopper,
            createPopper: createPopper$2,
            createPopperLite: createPopper$1,
            top: top,
            bottom: bottom,
            right: right,
            left: left,
            auto: auto,
            basePlacements: basePlacements,
            start: start,
            end: end,
            clippingParents: clippingParents,
            viewport: viewport,
            popper: popper,
            reference: reference,
            variationPlacements: variationPlacements,
            placements: placements,
            beforeRead: "beforeRead",
            read: "read",
            afterRead: "afterRead",
            beforeMain: "beforeMain",
            main: "main",
            afterMain: "afterMain",
            beforeWrite: "beforeWrite",
            write: "write",
            afterWrite: "afterWrite",
            modifierPhases: modifierPhases,
            applyStyles: applyStyles$1,
            arrow: arrow$1,
            computeStyles: computeStyles$1,
            eventListeners: eventListeners,
            flip: flip$1,
            hide: hide$1,
            offset: offset$1,
            popperOffsets: popperOffsets$1,
            preventOverflow: preventOverflow$1
        }),
        NAME$4 = "dropdown",
        REGEXP_KEYDOWN = new RegExp("ArrowUp|ArrowDown|Escape"),
        PLACEMENT_TOP = isRTL ? "top-end" : "top-start",
        PLACEMENT_TOPEND = isRTL ? "top-start" : "top-end",
        PLACEMENT_BOTTOM = isRTL ? "bottom-end" : "bottom-start",
        PLACEMENT_BOTTOMEND = isRTL ? "bottom-start" : "bottom-end",
        PLACEMENT_RIGHT = isRTL ? "left-start" : "right-start",
        PLACEMENT_LEFT = isRTL ? "right-start" : "left-start",
        Default$2 = {
            offset: 0,
            flip: !0,
            boundary: "clippingParents",
            reference: "toggle",
            display: "dynamic",
            popperConfig: null
        },
        DefaultType$2 = {
            offset: "(number|string|function)",
            flip: "boolean",
            boundary: "(string|element)",
            reference: "(string|element)",
            display: "string",
            popperConfig: "(null|object)"
        },
        Dropdown = function(_BaseComponent) {
            function Dropdown(element, config) {
                var _this;
                return (_this = _BaseComponent.call(this, element) || this)._popper = null, _this._config = _this._getConfig(config), _this._menu = _this._getMenuElement(), _this._inNavbar = _this._detectNavbar(), _this._addEventListeners(), _this
            }
            _inheritsLoose(Dropdown, _BaseComponent);
            var _proto = Dropdown.prototype;
            return _proto.toggle = function() {
                if (!this._element.disabled && !this._element.classList.contains("disabled")) {
                    var isActive = this._element.classList.contains("show");
                    Dropdown.clearMenus(), isActive || this.show()
                }
            }, _proto.show = function() {
                if (!(this._element.disabled || this._element.classList.contains("disabled") || this._menu.classList.contains("show"))) {
                    var parent = Dropdown.getParentFromElement(this._element),
                        relatedTarget = {
                            relatedTarget: this._element
                        };
                    if (!EventHandler.trigger(this._element, "show.bs.dropdown", relatedTarget).defaultPrevented) {
                        if (!this._inNavbar) {
                            if (void 0 === Popper) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                            var referenceElement = this._element;
                            "parent" === this._config.reference ? referenceElement = parent : isElement(this._config.reference) && (referenceElement = this._config.reference, void 0 !== this._config.reference.jquery && (referenceElement = this._config.reference[0])), this._popper = createPopper$2(referenceElement, this._menu, this._getPopperConfig())
                        }
                        var _ref;
                        if ("ontouchstart" in document.documentElement && !parent.closest(".navbar-nav"))(_ref = []).concat.apply(_ref, document.body.children).forEach((function(elem) {
                            return EventHandler.on(elem, "mouseover", null, (function() {}))
                        }));
                        this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), EventHandler.trigger(parent, "shown.bs.dropdown", relatedTarget)
                    }
                }
            }, _proto.hide = function() {
                if (!this._element.disabled && !this._element.classList.contains("disabled") && this._menu.classList.contains("show")) {
                    var parent = Dropdown.getParentFromElement(this._element),
                        relatedTarget = {
                            relatedTarget: this._element
                        };
                    EventHandler.trigger(parent, "hide.bs.dropdown", relatedTarget).defaultPrevented || (this._popper && this._popper.destroy(), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), EventHandler.trigger(parent, "hidden.bs.dropdown", relatedTarget))
                }
            }, _proto.dispose = function() {
                _BaseComponent.prototype.dispose.call(this), EventHandler.off(this._element, ".bs.dropdown"), this._menu = null, this._popper && (this._popper.destroy(), this._popper = null)
            }, _proto.update = function() {
                this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
            }, _proto._addEventListeners = function() {
                var _this2 = this;
                EventHandler.on(this._element, "click.bs.dropdown", (function(event) {
                    event.preventDefault(), event.stopPropagation(), _this2.toggle()
                }))
            }, _proto._getConfig = function(config) {
                return config = _extends({}, this.constructor.Default, Manipulator.getDataAttributes(this._element), config), typeCheckConfig(NAME$4, config, this.constructor.DefaultType), config
            }, _proto._getMenuElement = function() {
                return SelectorEngine.next(this._element, ".dropdown-menu")[0]
            }, _proto._getPlacement = function() {
                var parentDropdown = this._element.parentNode;
                if (parentDropdown.classList.contains("dropend")) return PLACEMENT_RIGHT;
                if (parentDropdown.classList.contains("dropstart")) return PLACEMENT_LEFT;
                var isEnd = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
                return parentDropdown.classList.contains("dropup") ? isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP : isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM
            }, _proto._detectNavbar = function() {
                return null !== this._element.closest(".navbar")
            }, _proto._getPopperConfig = function() {
                var popperConfig = {
                    placement: this._getPlacement(),
                    modifiers: [{
                        name: "preventOverflow",
                        options: {
                            altBoundary: this._config.flip,
                            rootBoundary: this._config.boundary
                        }
                    }]
                };
                return "static" === this._config.display && (popperConfig.modifiers = [{
                    name: "applyStyles",
                    enabled: !1
                }]), _extends({}, popperConfig, this._config.popperConfig)
            }, Dropdown.dropdownInterface = function(element, config) {
                var data = Data_getData(element, "bs.dropdown");
                if (data || (data = new Dropdown(element, "object" == typeof config ? config : null)), "string" == typeof config) {
                    if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                    data[config]()
                }
            }, Dropdown.jQueryInterface = function(config) {
                return this.each((function() {
                    Dropdown.dropdownInterface(this, config)
                }))
            }, Dropdown.clearMenus = function(event) {
                if (!event || 2 !== event.button && ("keyup" !== event.type || "Tab" === event.key))
                    for (var toggles = SelectorEngine.find('[data-bs-toggle="dropdown"]'), i = 0, len = toggles.length; i < len; i++) {
                        var parent = Dropdown.getParentFromElement(toggles[i]),
                            context = Data_getData(toggles[i], "bs.dropdown"),
                            relatedTarget = {
                                relatedTarget: toggles[i]
                            };
                        if (event && "click" === event.type && (relatedTarget.clickEvent = event), context) {
                            var dropdownMenu = context._menu;
                            if (toggles[i].classList.contains("show"))
                                if (!(event && ("click" === event.type && /input|textarea/i.test(event.target.tagName) || "keyup" === event.type && "Tab" === event.key) && dropdownMenu.contains(event.target)))
                                    if (!EventHandler.trigger(parent, "hide.bs.dropdown", relatedTarget).defaultPrevented) {
                                        var _ref2;
                                        if ("ontouchstart" in document.documentElement)(_ref2 = []).concat.apply(_ref2, document.body.children).forEach((function(elem) {
                                            return EventHandler.off(elem, "mouseover", null, (function() {}))
                                        }));
                                        toggles[i].setAttribute("aria-expanded", "false"), context._popper && context._popper.destroy(), dropdownMenu.classList.remove("show"), toggles[i].classList.remove("show"), EventHandler.trigger(parent, "hidden.bs.dropdown", relatedTarget)
                                    }
                        }
                    }
            }, Dropdown.getParentFromElement = function(element) {
                return getElementFromSelector(element) || element.parentNode
            }, Dropdown.dataApiKeydownHandler = function(event) {
                if (!(/input|textarea/i.test(event.target.tagName) ? "Space" === event.key || "Escape" !== event.key && ("ArrowDown" !== event.key && "ArrowUp" !== event.key || event.target.closest(".dropdown-menu")) : !REGEXP_KEYDOWN.test(event.key)) && (event.preventDefault(), event.stopPropagation(), !this.disabled && !this.classList.contains("disabled"))) {
                    var parent = Dropdown.getParentFromElement(this),
                        isActive = this.classList.contains("show");
                    if ("Escape" === event.key) return (this.matches('[data-bs-toggle="dropdown"]') ? this : SelectorEngine.prev(this, '[data-bs-toggle="dropdown"]')[0]).focus(), void Dropdown.clearMenus();
                    if (isActive && "Space" !== event.key) {
                        var items = SelectorEngine.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", parent).filter(isVisible);
                        if (items.length) {
                            var index = items.indexOf(event.target);
                            "ArrowUp" === event.key && index > 0 && index--, "ArrowDown" === event.key && index < items.length - 1 && index++, items[index = -1 === index ? 0 : index].focus()
                        }
                    } else Dropdown.clearMenus()
                }
            }, _createClass(Dropdown, null, [{
                key: "Default",
                get: function() {
                    return Default$2
                }
            }, {
                key: "DefaultType",
                get: function() {
                    return DefaultType$2
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.dropdown"
                }
            }]), Dropdown
        }(BaseComponent);
    EventHandler.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', Dropdown.dataApiKeydownHandler), EventHandler.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.dataApiKeydownHandler), EventHandler.on(document, "click.bs.dropdown.data-api", Dropdown.clearMenus), EventHandler.on(document, "keyup.bs.dropdown.data-api", Dropdown.clearMenus), EventHandler.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function(event) {
        event.preventDefault(), event.stopPropagation(), Dropdown.dropdownInterface(this, "toggle")
    })), EventHandler.on(document, "click.bs.dropdown.data-api", ".dropdown form", (function(e) {
        return e.stopPropagation()
    })), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn[NAME$4];
            $.fn[NAME$4] = Dropdown.jQueryInterface, $.fn[NAME$4].Constructor = Dropdown, $.fn[NAME$4].noConflict = function() {
                return $.fn[NAME$4] = JQUERY_NO_CONFLICT, Dropdown.jQueryInterface
            }
        }
    }));
    var Default$3 = {
            backdrop: !0,
            keyboard: !0,
            focus: !0
        },
        DefaultType$3 = {
            backdrop: "(boolean|string)",
            keyboard: "boolean",
            focus: "boolean"
        },
        Modal = function(_BaseComponent) {
            function Modal(element, config) {
                var _this;
                return (_this = _BaseComponent.call(this, element) || this)._config = _this._getConfig(config), _this._dialog = SelectorEngine.findOne(".modal-dialog", element), _this._backdrop = null, _this._isShown = !1, _this._isBodyOverflowing = !1, _this._ignoreBackdropClick = !1, _this._isTransitioning = !1, _this._scrollbarWidth = 0, _this
            }
            _inheritsLoose(Modal, _BaseComponent);
            var _proto = Modal.prototype;
            return _proto.toggle = function(relatedTarget) {
                return this._isShown ? this.hide() : this.show(relatedTarget)
            }, _proto.show = function(relatedTarget) {
                var _this2 = this;
                if (!this._isShown && !this._isTransitioning) {
                    this._element.classList.contains("fade") && (this._isTransitioning = !0);
                    var showEvent = EventHandler.trigger(this._element, "show.bs.modal", {
                        relatedTarget: relatedTarget
                    });
                    this._isShown || showEvent.defaultPrevented || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), EventHandler.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', (function(event) {
                        return _this2.hide(event)
                    })), EventHandler.on(this._dialog, "mousedown.dismiss.bs.modal", (function() {
                        EventHandler.one(_this2._element, "mouseup.dismiss.bs.modal", (function(event) {
                            event.target === _this2._element && (_this2._ignoreBackdropClick = !0)
                        }))
                    })), this._showBackdrop((function() {
                        return _this2._showElement(relatedTarget)
                    })))
                }
            }, _proto.hide = function(event) {
                var _this3 = this;
                if ((event && event.preventDefault(), this._isShown && !this._isTransitioning) && !EventHandler.trigger(this._element, "hide.bs.modal").defaultPrevented) {
                    this._isShown = !1;
                    var transition = this._element.classList.contains("fade");
                    if (transition && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), EventHandler.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), EventHandler.off(this._element, "click.dismiss.bs.modal"), EventHandler.off(this._dialog, "mousedown.dismiss.bs.modal"), transition) {
                        var transitionDuration = getTransitionDurationFromElement(this._element);
                        EventHandler.one(this._element, "transitionend", (function(event) {
                            return _this3._hideModal(event)
                        })), emulateTransitionEnd(this._element, transitionDuration)
                    } else this._hideModal()
                }
            }, _proto.dispose = function() {
                [window, this._element, this._dialog].forEach((function(htmlElement) {
                    return EventHandler.off(htmlElement, ".bs.modal")
                })), _BaseComponent.prototype.dispose.call(this), EventHandler.off(document, "focusin.bs.modal"), this._config = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null
            }, _proto.handleUpdate = function() {
                this._adjustDialog()
            }, _proto._getConfig = function(config) {
                return config = _extends({}, Default$3, config), typeCheckConfig("modal", config, DefaultType$3), config
            }, _proto._showElement = function(relatedTarget) {
                var _this4 = this,
                    transition = this._element.classList.contains("fade"),
                    modalBody = SelectorEngine.findOne(".modal-body", this._dialog);
                this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, modalBody && (modalBody.scrollTop = 0), transition && reflow(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus();
                var transitionComplete = function() {
                    _this4._config.focus && _this4._element.focus(), _this4._isTransitioning = !1, EventHandler.trigger(_this4._element, "shown.bs.modal", {
                        relatedTarget: relatedTarget
                    })
                };
                if (transition) {
                    var transitionDuration = getTransitionDurationFromElement(this._dialog);
                    EventHandler.one(this._dialog, "transitionend", transitionComplete), emulateTransitionEnd(this._dialog, transitionDuration)
                } else transitionComplete()
            }, _proto._enforceFocus = function() {
                var _this5 = this;
                EventHandler.off(document, "focusin.bs.modal"), EventHandler.on(document, "focusin.bs.modal", (function(event) {
                    document === event.target || _this5._element === event.target || _this5._element.contains(event.target) || _this5._element.focus()
                }))
            }, _proto._setEscapeEvent = function() {
                var _this6 = this;
                this._isShown ? EventHandler.on(this._element, "keydown.dismiss.bs.modal", (function(event) {
                    _this6._config.keyboard && "Escape" === event.key ? (event.preventDefault(), _this6.hide()) : _this6._config.keyboard || "Escape" !== event.key || _this6._triggerBackdropTransition()
                })) : EventHandler.off(this._element, "keydown.dismiss.bs.modal")
            }, _proto._setResizeEvent = function() {
                var _this7 = this;
                this._isShown ? EventHandler.on(window, "resize.bs.modal", (function() {
                    return _this7._adjustDialog()
                })) : EventHandler.off(window, "resize.bs.modal")
            }, _proto._hideModal = function() {
                var _this8 = this;
                this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._showBackdrop((function() {
                    document.body.classList.remove("modal-open"), _this8._resetAdjustments(), _this8._resetScrollbar(), EventHandler.trigger(_this8._element, "hidden.bs.modal")
                }))
            }, _proto._removeBackdrop = function() {
                this._backdrop.parentNode.removeChild(this._backdrop), this._backdrop = null
            }, _proto._showBackdrop = function(callback) {
                var _this9 = this,
                    animate = this._element.classList.contains("fade") ? "fade" : "";
                if (this._isShown && this._config.backdrop) {
                    if (this._backdrop = document.createElement("div"), this._backdrop.className = "modal-backdrop", animate && this._backdrop.classList.add(animate), document.body.appendChild(this._backdrop), EventHandler.on(this._element, "click.dismiss.bs.modal", (function(event) {
                            _this9._ignoreBackdropClick ? _this9._ignoreBackdropClick = !1 : event.target === event.currentTarget && ("static" === _this9._config.backdrop ? _this9._triggerBackdropTransition() : _this9.hide())
                        })), animate && reflow(this._backdrop), this._backdrop.classList.add("show"), !animate) return void callback();
                    var backdropTransitionDuration = getTransitionDurationFromElement(this._backdrop);
                    EventHandler.one(this._backdrop, "transitionend", callback), emulateTransitionEnd(this._backdrop, backdropTransitionDuration)
                } else if (!this._isShown && this._backdrop) {
                    this._backdrop.classList.remove("show");
                    var callbackRemove = function() {
                        _this9._removeBackdrop(), callback()
                    };
                    if (this._element.classList.contains("fade")) {
                        var _backdropTransitionDuration = getTransitionDurationFromElement(this._backdrop);
                        EventHandler.one(this._backdrop, "transitionend", callbackRemove), emulateTransitionEnd(this._backdrop, _backdropTransitionDuration)
                    } else callbackRemove()
                } else callback()
            }, _proto._triggerBackdropTransition = function() {
                var _this10 = this;
                if (!EventHandler.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) {
                    var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                    isModalOverflowing || (this._element.style.overflowY = "hidden"), this._element.classList.add("modal-static");
                    var modalTransitionDuration = getTransitionDurationFromElement(this._dialog);
                    EventHandler.off(this._element, "transitionend"), EventHandler.one(this._element, "transitionend", (function() {
                        _this10._element.classList.remove("modal-static"), isModalOverflowing || (EventHandler.one(_this10._element, "transitionend", (function() {
                            _this10._element.style.overflowY = ""
                        })), emulateTransitionEnd(_this10._element, modalTransitionDuration))
                    })), emulateTransitionEnd(this._element, modalTransitionDuration), this._element.focus()
                }
            }, _proto._adjustDialog = function() {
                var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                (!this._isBodyOverflowing && isModalOverflowing && !isRTL || this._isBodyOverflowing && !isModalOverflowing && isRTL) && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), (this._isBodyOverflowing && !isModalOverflowing && !isRTL || !this._isBodyOverflowing && isModalOverflowing && isRTL) && (this._element.style.paddingRight = this._scrollbarWidth + "px")
            }, _proto._resetAdjustments = function() {
                this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
            }, _proto._checkScrollbar = function() {
                var rect = document.body.getBoundingClientRect();
                this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
            }, _proto._setScrollbar = function() {
                var _this11 = this;
                if (this._isBodyOverflowing) {
                    SelectorEngine.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(element) {
                        var actualPadding = element.style.paddingRight,
                            calculatedPadding = window.getComputedStyle(element)["padding-right"];
                        Manipulator.setDataAttribute(element, "padding-right", actualPadding), element.style.paddingRight = Number.parseFloat(calculatedPadding) + _this11._scrollbarWidth + "px"
                    })), SelectorEngine.find(".sticky-top").forEach((function(element) {
                        var actualMargin = element.style.marginRight,
                            calculatedMargin = window.getComputedStyle(element)["margin-right"];
                        Manipulator.setDataAttribute(element, "margin-right", actualMargin), element.style.marginRight = Number.parseFloat(calculatedMargin) - _this11._scrollbarWidth + "px"
                    }));
                    var actualPadding = document.body.style.paddingRight,
                        calculatedPadding = window.getComputedStyle(document.body)["padding-right"];
                    Manipulator.setDataAttribute(document.body, "padding-right", actualPadding), document.body.style.paddingRight = Number.parseFloat(calculatedPadding) + this._scrollbarWidth + "px"
                }
                document.body.classList.add("modal-open")
            }, _proto._resetScrollbar = function() {
                SelectorEngine.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(element) {
                    var padding = Manipulator.getDataAttribute(element, "padding-right");
                    void 0 !== padding && (Manipulator.removeDataAttribute(element, "padding-right"), element.style.paddingRight = padding)
                })), SelectorEngine.find(".sticky-top").forEach((function(element) {
                    var margin = Manipulator.getDataAttribute(element, "margin-right");
                    void 0 !== margin && (Manipulator.removeDataAttribute(element, "margin-right"), element.style.marginRight = margin)
                }));
                var padding = Manipulator.getDataAttribute(document.body, "padding-right");
                void 0 === padding ? document.body.style.paddingRight = "" : (Manipulator.removeDataAttribute(document.body, "padding-right"), document.body.style.paddingRight = padding)
            }, _proto._getScrollbarWidth = function() {
                var scrollDiv = document.createElement("div");
                scrollDiv.className = "modal-scrollbar-measure", document.body.appendChild(scrollDiv);
                var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
                return document.body.removeChild(scrollDiv), scrollbarWidth
            }, Modal.jQueryInterface = function(config, relatedTarget) {
                return this.each((function() {
                    var data = Data_getData(this, "bs.modal"),
                        _config = _extends({}, Default$3, Manipulator.getDataAttributes(this), "object" == typeof config && config ? config : {});
                    if (data || (data = new Modal(this, _config)), "string" == typeof config) {
                        if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                        data[config](relatedTarget)
                    }
                }))
            }, _createClass(Modal, null, [{
                key: "Default",
                get: function() {
                    return Default$3
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.modal"
                }
            }]), Modal
        }(BaseComponent);
    EventHandler.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function(event) {
        var _this12 = this,
            target = getElementFromSelector(this);
        "A" !== this.tagName && "AREA" !== this.tagName || event.preventDefault(), EventHandler.one(target, "show.bs.modal", (function(showEvent) {
            showEvent.defaultPrevented || EventHandler.one(target, "hidden.bs.modal", (function() {
                isVisible(_this12) && _this12.focus()
            }))
        }));
        var data = Data_getData(target, "bs.modal");
        if (!data) {
            var config = _extends({}, Manipulator.getDataAttributes(target), Manipulator.getDataAttributes(this));
            data = new Modal(target, config)
        }
        data.show(this)
    })), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn.modal;
            $.fn.modal = Modal.jQueryInterface, $.fn.modal.Constructor = Modal, $.fn.modal.noConflict = function() {
                return $.fn.modal = JQUERY_NO_CONFLICT, Modal.jQueryInterface
            }
        }
    }));
    var uriAttrs = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
        SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,
        DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
        DefaultAllowlist = {
            "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
            a: ["target", "href", "title", "rel"],
            area: [],
            b: [],
            br: [],
            col: [],
            code: [],
            div: [],
            em: [],
            hr: [],
            h1: [],
            h2: [],
            h3: [],
            h4: [],
            h5: [],
            h6: [],
            i: [],
            img: ["src", "srcset", "alt", "title", "width", "height"],
            li: [],
            ol: [],
            p: [],
            pre: [],
            s: [],
            small: [],
            span: [],
            sub: [],
            sup: [],
            strong: [],
            u: [],
            ul: []
        };

    function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
        var _ref;
        if (!unsafeHtml.length) return unsafeHtml;
        if (sanitizeFn && "function" == typeof sanitizeFn) return sanitizeFn(unsafeHtml);
        for (var createdDocument = (new window.DOMParser).parseFromString(unsafeHtml, "text/html"), allowlistKeys = Object.keys(allowList), elements = (_ref = []).concat.apply(_ref, createdDocument.body.querySelectorAll("*")), _loop = function(i, len) {
                var _ref2, el = elements[i],
                    elName = el.nodeName.toLowerCase();
                if (!allowlistKeys.includes(elName)) return el.parentNode.removeChild(el), "continue";
                var attributeList = (_ref2 = []).concat.apply(_ref2, el.attributes),
                    allowedAttributes = [].concat(allowList["*"] || [], allowList[elName] || []);
                attributeList.forEach((function(attr) {
                    (function(attr, allowedAttributeList) {
                        var attrName = attr.nodeName.toLowerCase();
                        if (allowedAttributeList.includes(attrName)) return !uriAttrs.has(attrName) || Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
                        for (var regExp = allowedAttributeList.filter((function(attrRegex) {
                                return attrRegex instanceof RegExp
                            })), i = 0, len = regExp.length; i < len; i++)
                            if (attrName.match(regExp[i])) return !0;
                        return !1
                    })(attr, allowedAttributes) || el.removeAttribute(attr.nodeName)
                }))
            }, i = 0, len = elements.length; i < len; i++) _loop(i);
        return createdDocument.body.innerHTML
    }
    var NAME$6 = "tooltip",
        BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
        DISALLOWED_ATTRIBUTES = new Set(["sanitize", "allowList", "sanitizeFn"]),
        DefaultType$4 = {
            animation: "boolean",
            template: "string",
            title: "(string|element|function)",
            trigger: "string",
            delay: "(number|object)",
            html: "boolean",
            selector: "(string|boolean)",
            placement: "(string|function)",
            container: "(string|element|boolean)",
            fallbackPlacements: "(null|array)",
            boundary: "(string|element)",
            customClass: "(string|function)",
            sanitize: "boolean",
            sanitizeFn: "(null|function)",
            allowList: "object",
            popperConfig: "(null|object)"
        },
        AttachmentMap = {
            AUTO: "auto",
            TOP: "top",
            RIGHT: isRTL ? "left" : "right",
            BOTTOM: "bottom",
            LEFT: isRTL ? "right" : "left"
        },
        Default$4 = {
            animation: !0,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: !1,
            selector: !1,
            placement: "top",
            container: !1,
            fallbackPlacements: null,
            boundary: "clippingParents",
            customClass: "",
            sanitize: !0,
            sanitizeFn: null,
            allowList: DefaultAllowlist,
            popperConfig: null
        },
        Event$1 = {
            HIDE: "hide.bs.tooltip",
            HIDDEN: "hidden.bs.tooltip",
            SHOW: "show.bs.tooltip",
            SHOWN: "shown.bs.tooltip",
            INSERTED: "inserted.bs.tooltip",
            CLICK: "click.bs.tooltip",
            FOCUSIN: "focusin.bs.tooltip",
            FOCUSOUT: "focusout.bs.tooltip",
            MOUSEENTER: "mouseenter.bs.tooltip",
            MOUSELEAVE: "mouseleave.bs.tooltip"
        },
        Tooltip = function(_BaseComponent) {
            function Tooltip(element, config) {
                var _this;
                if (void 0 === Popper) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                return (_this = _BaseComponent.call(this, element) || this)._isEnabled = !0, _this._timeout = 0, _this._hoverState = "", _this._activeTrigger = {}, _this._popper = null, _this.config = _this._getConfig(config), _this.tip = null, _this._setListeners(), _this
            }
            _inheritsLoose(Tooltip, _BaseComponent);
            var _proto = Tooltip.prototype;
            return _proto.enable = function() {
                this._isEnabled = !0
            }, _proto.disable = function() {
                this._isEnabled = !1
            }, _proto.toggleEnabled = function() {
                this._isEnabled = !this._isEnabled
            }, _proto.toggle = function(event) {
                if (this._isEnabled)
                    if (event) {
                        var dataKey = this.constructor.DATA_KEY,
                            context = Data_getData(event.delegateTarget, dataKey);
                        context || (context = new this.constructor(event.delegateTarget, this._getDelegateConfig()), Data_setData(event.delegateTarget, dataKey, context)), context._activeTrigger.click = !context._activeTrigger.click, context._isWithActiveTrigger() ? context._enter(null, context) : context._leave(null, context)
                    } else {
                        if (this.getTipElement().classList.contains("show")) return void this._leave(null, this);
                        this._enter(null, this)
                    }
            }, _proto.dispose = function() {
                clearTimeout(this._timeout), EventHandler.off(this._element, this.constructor.EVENT_KEY), EventHandler.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.parentNode.removeChild(this.tip), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.config = null, this.tip = null, _BaseComponent.prototype.dispose.call(this)
            }, _proto.show = function() {
                var _this2 = this;
                if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
                if (this.isWithContent() && this._isEnabled) {
                    var showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW),
                        shadowRoot = findShadowRoot(this._element),
                        isInTheDom = null === shadowRoot ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);
                    if (showEvent.defaultPrevented || !isInTheDom) return;
                    var tip = this.getTipElement(),
                        tipId = getUID(this.constructor.NAME);
                    tip.setAttribute("id", tipId), this._element.setAttribute("aria-describedby", tipId), this.setContent(), this.config.animation && tip.classList.add("fade");
                    var placement = "function" == typeof this.config.placement ? this.config.placement.call(this, tip, this._element) : this.config.placement,
                        attachment = this._getAttachment(placement);
                    this._addAttachmentClass(attachment);
                    var container = this._getContainer();
                    Data_setData(tip, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || container.appendChild(tip), EventHandler.trigger(this._element, this.constructor.Event.INSERTED), this._popper = createPopper$2(this._element, tip, this._getPopperConfig(attachment)), tip.classList.add("show");
                    var _tip$classList, _ref, customClass = "function" == typeof this.config.customClass ? this.config.customClass() : this.config.customClass;
                    if (customClass)(_tip$classList = tip.classList).add.apply(_tip$classList, customClass.split(" "));
                    if ("ontouchstart" in document.documentElement)(_ref = []).concat.apply(_ref, document.body.children).forEach((function(element) {
                        EventHandler.on(element, "mouseover", (function() {}))
                    }));
                    var complete = function() {
                        var prevHoverState = _this2._hoverState;
                        _this2._hoverState = null, EventHandler.trigger(_this2._element, _this2.constructor.Event.SHOWN), "out" === prevHoverState && _this2._leave(null, _this2)
                    };
                    if (this.tip.classList.contains("fade")) {
                        var transitionDuration = getTransitionDurationFromElement(this.tip);
                        EventHandler.one(this.tip, "transitionend", complete), emulateTransitionEnd(this.tip, transitionDuration)
                    } else complete()
                }
            }, _proto.hide = function() {
                var _this3 = this;
                if (this._popper) {
                    var tip = this.getTipElement(),
                        complete = function() {
                            "show" !== _this3._hoverState && tip.parentNode && tip.parentNode.removeChild(tip), _this3._cleanTipClass(), _this3._element.removeAttribute("aria-describedby"), EventHandler.trigger(_this3._element, _this3.constructor.Event.HIDDEN), _this3._popper && (_this3._popper.destroy(), _this3._popper = null)
                        };
                    if (!EventHandler.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) {
                        var _ref2;
                        if (tip.classList.remove("show"), "ontouchstart" in document.documentElement)(_ref2 = []).concat.apply(_ref2, document.body.children).forEach((function(element) {
                            return EventHandler.off(element, "mouseover", noop)
                        }));
                        if (this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this.tip.classList.contains("fade")) {
                            var transitionDuration = getTransitionDurationFromElement(tip);
                            EventHandler.one(tip, "transitionend", complete), emulateTransitionEnd(tip, transitionDuration)
                        } else complete();
                        this._hoverState = ""
                    }
                }
            }, _proto.update = function() {
                null !== this._popper && this._popper.update()
            }, _proto.isWithContent = function() {
                return Boolean(this.getTitle())
            }, _proto.getTipElement = function() {
                if (this.tip) return this.tip;
                var element = document.createElement("div");
                return element.innerHTML = this.config.template, this.tip = element.children[0], this.tip
            }, _proto.setContent = function() {
                var tip = this.getTipElement();
                this.setElementContent(SelectorEngine.findOne(".tooltip-inner", tip), this.getTitle()), tip.classList.remove("fade", "show")
            }, _proto.setElementContent = function(element, content) {
                if (null !== element) return "object" == typeof content && isElement(content) ? (content.jquery && (content = content[0]), void(this.config.html ? content.parentNode !== element && (element.innerHTML = "", element.appendChild(content)) : element.textContent = content.textContent)) : void(this.config.html ? (this.config.sanitize && (content = sanitizeHtml(content, this.config.allowList, this.config.sanitizeFn)), element.innerHTML = content) : element.textContent = content)
            }, _proto.getTitle = function() {
                var title = this._element.getAttribute("data-bs-original-title");
                return title || (title = "function" == typeof this.config.title ? this.config.title.call(this._element) : this.config.title), title
            }, _proto.updateAttachment = function(attachment) {
                return "right" === attachment ? "end" : "left" === attachment ? "start" : attachment
            }, _proto._getPopperConfig = function(attachment) {
                var _this4 = this,
                    flipModifier = {
                        name: "flip",
                        options: {
                            altBoundary: !0
                        }
                    };
                return this.config.fallbackPlacements && (flipModifier.options.fallbackPlacements = this.config.fallbackPlacements), _extends({}, {
                    placement: attachment,
                    modifiers: [flipModifier, {
                        name: "preventOverflow",
                        options: {
                            rootBoundary: this.config.boundary
                        }
                    }, {
                        name: "arrow",
                        options: {
                            element: "." + this.constructor.NAME + "-arrow"
                        }
                    }, {
                        name: "onChange",
                        enabled: !0,
                        phase: "afterWrite",
                        fn: function(data) {
                            return _this4._handlePopperPlacementChange(data)
                        }
                    }],
                    onFirstUpdate: function(data) {
                        data.options.placement !== data.placement && _this4._handlePopperPlacementChange(data)
                    }
                }, this.config.popperConfig)
            }, _proto._addAttachmentClass = function(attachment) {
                this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(attachment))
            }, _proto._getContainer = function() {
                return !1 === this.config.container ? document.body : isElement(this.config.container) ? this.config.container : SelectorEngine.findOne(this.config.container)
            }, _proto._getAttachment = function(placement) {
                return AttachmentMap[placement.toUpperCase()]
            }, _proto._setListeners = function() {
                var _this5 = this;
                this.config.trigger.split(" ").forEach((function(trigger) {
                    if ("click" === trigger) EventHandler.on(_this5._element, _this5.constructor.Event.CLICK, _this5.config.selector, (function(event) {
                        return _this5.toggle(event)
                    }));
                    else if ("manual" !== trigger) {
                        var eventIn = "hover" === trigger ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN,
                            eventOut = "hover" === trigger ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
                        EventHandler.on(_this5._element, eventIn, _this5.config.selector, (function(event) {
                            return _this5._enter(event)
                        })), EventHandler.on(_this5._element, eventOut, _this5.config.selector, (function(event) {
                            return _this5._leave(event)
                        }))
                    }
                })), this._hideModalHandler = function() {
                    _this5._element && _this5.hide()
                }, EventHandler.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.config.selector ? this.config = _extends({}, this.config, {
                    trigger: "manual",
                    selector: ""
                }) : this._fixTitle()
            }, _proto._fixTitle = function() {
                var title = this._element.getAttribute("title"),
                    originalTitleType = typeof this._element.getAttribute("data-bs-original-title");
                (title || "string" !== originalTitleType) && (this._element.setAttribute("data-bs-original-title", title || ""), !title || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", title), this._element.setAttribute("title", ""))
            }, _proto._enter = function(event, context) {
                var dataKey = this.constructor.DATA_KEY;
                (context = context || Data_getData(event.delegateTarget, dataKey)) || (context = new this.constructor(event.delegateTarget, this._getDelegateConfig()), Data_setData(event.delegateTarget, dataKey, context)), event && (context._activeTrigger["focusin" === event.type ? "focus" : "hover"] = !0), context.getTipElement().classList.contains("show") || "show" === context._hoverState ? context._hoverState = "show" : (clearTimeout(context._timeout), context._hoverState = "show", context.config.delay && context.config.delay.show ? context._timeout = setTimeout((function() {
                    "show" === context._hoverState && context.show()
                }), context.config.delay.show) : context.show())
            }, _proto._leave = function(event, context) {
                var dataKey = this.constructor.DATA_KEY;
                (context = context || Data_getData(event.delegateTarget, dataKey)) || (context = new this.constructor(event.delegateTarget, this._getDelegateConfig()), Data_setData(event.delegateTarget, dataKey, context)), event && (context._activeTrigger["focusout" === event.type ? "focus" : "hover"] = !1), context._isWithActiveTrigger() || (clearTimeout(context._timeout), context._hoverState = "out", context.config.delay && context.config.delay.hide ? context._timeout = setTimeout((function() {
                    "out" === context._hoverState && context.hide()
                }), context.config.delay.hide) : context.hide())
            }, _proto._isWithActiveTrigger = function() {
                for (var trigger in this._activeTrigger)
                    if (this._activeTrigger[trigger]) return !0;
                return !1
            }, _proto._getConfig = function(config) {
                var dataAttributes = Manipulator.getDataAttributes(this._element);
                return Object.keys(dataAttributes).forEach((function(dataAttr) {
                    DISALLOWED_ATTRIBUTES.has(dataAttr) && delete dataAttributes[dataAttr]
                })), config && "object" == typeof config.container && config.container.jquery && (config.container = config.container[0]), "number" == typeof(config = _extends({}, this.constructor.Default, dataAttributes, "object" == typeof config && config ? config : {})).delay && (config.delay = {
                    show: config.delay,
                    hide: config.delay
                }), "number" == typeof config.title && (config.title = config.title.toString()), "number" == typeof config.content && (config.content = config.content.toString()), typeCheckConfig(NAME$6, config, this.constructor.DefaultType), config.sanitize && (config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn)), config
            }, _proto._getDelegateConfig = function() {
                var config = {};
                if (this.config)
                    for (var key in this.config) this.constructor.Default[key] !== this.config[key] && (config[key] = this.config[key]);
                return config
            }, _proto._cleanTipClass = function() {
                var tip = this.getTipElement(),
                    tabClass = tip.getAttribute("class").match(BSCLS_PREFIX_REGEX);
                null !== tabClass && tabClass.length > 0 && tabClass.map((function(token) {
                    return token.trim()
                })).forEach((function(tClass) {
                    return tip.classList.remove(tClass)
                }))
            }, _proto._handlePopperPlacementChange = function(popperData) {
                var state = popperData.state;
                state && (this.tip = state.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(state.placement)))
            }, Tooltip.jQueryInterface = function(config) {
                return this.each((function() {
                    var data = Data_getData(this, "bs.tooltip"),
                        _config = "object" == typeof config && config;
                    if ((data || !/dispose|hide/.test(config)) && (data || (data = new Tooltip(this, _config)), "string" == typeof config)) {
                        if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                        data[config]()
                    }
                }))
            }, _createClass(Tooltip, null, [{
                key: "Default",
                get: function() {
                    return Default$4
                }
            }, {
                key: "NAME",
                get: function() {
                    return NAME$6
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.tooltip"
                }
            }, {
                key: "Event",
                get: function() {
                    return Event$1
                }
            }, {
                key: "EVENT_KEY",
                get: function() {
                    return ".bs.tooltip"
                }
            }, {
                key: "DefaultType",
                get: function() {
                    return DefaultType$4
                }
            }]), Tooltip
        }(BaseComponent);
    onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn[NAME$6];
            $.fn[NAME$6] = Tooltip.jQueryInterface, $.fn[NAME$6].Constructor = Tooltip, $.fn[NAME$6].noConflict = function() {
                return $.fn[NAME$6] = JQUERY_NO_CONFLICT, Tooltip.jQueryInterface
            }
        }
    }));
    var NAME$7 = "popover",
        BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)bs-popover\\S+", "g"),
        Default$5 = _extends({}, Tooltip.Default, {
            placement: "right",
            trigger: "click",
            content: "",
            template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        }),
        DefaultType$5 = _extends({}, Tooltip.DefaultType, {
            content: "(string|element|function)"
        }),
        Event$2 = {
            HIDE: "hide.bs.popover",
            HIDDEN: "hidden.bs.popover",
            SHOW: "show.bs.popover",
            SHOWN: "shown.bs.popover",
            INSERTED: "inserted.bs.popover",
            CLICK: "click.bs.popover",
            FOCUSIN: "focusin.bs.popover",
            FOCUSOUT: "focusout.bs.popover",
            MOUSEENTER: "mouseenter.bs.popover",
            MOUSELEAVE: "mouseleave.bs.popover"
        },
        Popover = function(_Tooltip) {
            function Popover() {
                return _Tooltip.apply(this, arguments) || this
            }
            _inheritsLoose(Popover, _Tooltip);
            var _proto = Popover.prototype;
            return _proto.isWithContent = function() {
                return this.getTitle() || this._getContent()
            }, _proto.setContent = function() {
                var tip = this.getTipElement();
                this.setElementContent(SelectorEngine.findOne(".popover-header", tip), this.getTitle());
                var content = this._getContent();
                "function" == typeof content && (content = content.call(this._element)), this.setElementContent(SelectorEngine.findOne(".popover-body", tip), content), tip.classList.remove("fade", "show")
            }, _proto._addAttachmentClass = function(attachment) {
                this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(attachment))
            }, _proto._getContent = function() {
                return this._element.getAttribute("data-bs-content") || this.config.content
            }, _proto._cleanTipClass = function() {
                var tip = this.getTipElement(),
                    tabClass = tip.getAttribute("class").match(BSCLS_PREFIX_REGEX$1);
                null !== tabClass && tabClass.length > 0 && tabClass.map((function(token) {
                    return token.trim()
                })).forEach((function(tClass) {
                    return tip.classList.remove(tClass)
                }))
            }, Popover.jQueryInterface = function(config) {
                return this.each((function() {
                    var data = Data_getData(this, "bs.popover"),
                        _config = "object" == typeof config ? config : null;
                    if ((data || !/dispose|hide/.test(config)) && (data || (data = new Popover(this, _config), Data_setData(this, "bs.popover", data)), "string" == typeof config)) {
                        if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                        data[config]()
                    }
                }))
            }, _createClass(Popover, null, [{
                key: "Default",
                get: function() {
                    return Default$5
                }
            }, {
                key: "NAME",
                get: function() {
                    return NAME$7
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.popover"
                }
            }, {
                key: "Event",
                get: function() {
                    return Event$2
                }
            }, {
                key: "EVENT_KEY",
                get: function() {
                    return ".bs.popover"
                }
            }, {
                key: "DefaultType",
                get: function() {
                    return DefaultType$5
                }
            }]), Popover
        }(Tooltip);
    onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn[NAME$7];
            $.fn[NAME$7] = Popover.jQueryInterface, $.fn[NAME$7].Constructor = Popover, $.fn[NAME$7].noConflict = function() {
                return $.fn[NAME$7] = JQUERY_NO_CONFLICT, Popover.jQueryInterface
            }
        }
    }));
    var NAME$8 = "scrollspy",
        Default$6 = {
            offset: 10,
            method: "auto",
            target: ""
        },
        DefaultType$6 = {
            offset: "number",
            method: "string",
            target: "(string|element)"
        },
        ScrollSpy = function(_BaseComponent) {
            function ScrollSpy(element, config) {
                var _this;
                return (_this = _BaseComponent.call(this, element) || this)._scrollElement = "BODY" === element.tagName ? window : element, _this._config = _this._getConfig(config), _this._selector = _this._config.target + " .nav-link, " + _this._config.target + " .list-group-item, " + _this._config.target + " .dropdown-item", _this._offsets = [], _this._targets = [], _this._activeTarget = null, _this._scrollHeight = 0, EventHandler.on(_this._scrollElement, "scroll.bs.scrollspy", (function(event) {
                    return _this._process(event)
                })), _this.refresh(), _this._process(), _this
            }
            _inheritsLoose(ScrollSpy, _BaseComponent);
            var _proto = ScrollSpy.prototype;
            return _proto.refresh = function() {
                var _this2 = this,
                    autoMethod = this._scrollElement === this._scrollElement.window ? "offset" : "position",
                    offsetMethod = "auto" === this._config.method ? autoMethod : this._config.method,
                    offsetBase = "position" === offsetMethod ? this._getScrollTop() : 0;
                this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), SelectorEngine.find(this._selector).map((function(element) {
                    var targetSelector = getSelectorFromElement(element),
                        target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;
                    if (target) {
                        var targetBCR = target.getBoundingClientRect();
                        if (targetBCR.width || targetBCR.height) return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector]
                    }
                    return null
                })).filter((function(item) {
                    return item
                })).sort((function(a, b) {
                    return a[0] - b[0]
                })).forEach((function(item) {
                    _this2._offsets.push(item[0]), _this2._targets.push(item[1])
                }))
            }, _proto.dispose = function() {
                _BaseComponent.prototype.dispose.call(this), EventHandler.off(this._scrollElement, ".bs.scrollspy"), this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
            }, _proto._getConfig = function(config) {
                if ("string" != typeof(config = _extends({}, Default$6, "object" == typeof config && config ? config : {})).target && isElement(config.target)) {
                    var id = config.target.id;
                    id || (id = getUID(NAME$8), config.target.id = id), config.target = "#" + id
                }
                return typeCheckConfig(NAME$8, config, DefaultType$6), config
            }, _proto._getScrollTop = function() {
                return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
            }, _proto._getScrollHeight = function() {
                return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
            }, _proto._getOffsetHeight = function() {
                return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
            }, _proto._process = function() {
                var scrollTop = this._getScrollTop() + this._config.offset,
                    scrollHeight = this._getScrollHeight(),
                    maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
                if (this._scrollHeight !== scrollHeight && this.refresh(), scrollTop >= maxScroll) {
                    var target = this._targets[this._targets.length - 1];
                    this._activeTarget !== target && this._activate(target)
                } else {
                    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
                    for (var i = this._offsets.length; i--;) {
                        this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (void 0 === this._offsets[i + 1] || scrollTop < this._offsets[i + 1]) && this._activate(this._targets[i])
                    }
                }
            }, _proto._activate = function(target) {
                this._activeTarget = target, this._clear();
                var queries = this._selector.split(",").map((function(selector) {
                        return selector + '[data-bs-target="' + target + '"],' + selector + '[href="' + target + '"]'
                    })),
                    link = SelectorEngine.findOne(queries.join(","));
                link.classList.contains("dropdown-item") ? (SelectorEngine.findOne(".dropdown-toggle", link.closest(".dropdown")).classList.add("active"), link.classList.add("active")) : (link.classList.add("active"), SelectorEngine.parents(link, ".nav, .list-group").forEach((function(listGroup) {
                    SelectorEngine.prev(listGroup, ".nav-link, .list-group-item").forEach((function(item) {
                        return item.classList.add("active")
                    })), SelectorEngine.prev(listGroup, ".nav-item").forEach((function(navItem) {
                        SelectorEngine.children(navItem, ".nav-link").forEach((function(item) {
                            return item.classList.add("active")
                        }))
                    }))
                }))), EventHandler.trigger(this._scrollElement, "activate.bs.scrollspy", {
                    relatedTarget: target
                })
            }, _proto._clear = function() {
                SelectorEngine.find(this._selector).filter((function(node) {
                    return node.classList.contains("active")
                })).forEach((function(node) {
                    return node.classList.remove("active")
                }))
            }, ScrollSpy.jQueryInterface = function(config) {
                return this.each((function() {
                    var data = Data_getData(this, "bs.scrollspy");
                    if (data || (data = new ScrollSpy(this, "object" == typeof config && config)), "string" == typeof config) {
                        if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                        data[config]()
                    }
                }))
            }, _createClass(ScrollSpy, null, [{
                key: "Default",
                get: function() {
                    return Default$6
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.scrollspy"
                }
            }]), ScrollSpy
        }(BaseComponent);
    EventHandler.on(window, "load.bs.scrollspy.data-api", (function() {
        SelectorEngine.find('[data-bs-spy="scroll"]').forEach((function(spy) {
            return new ScrollSpy(spy, Manipulator.getDataAttributes(spy))
        }))
    })), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn[NAME$8];
            $.fn[NAME$8] = ScrollSpy.jQueryInterface, $.fn[NAME$8].Constructor = ScrollSpy, $.fn[NAME$8].noConflict = function() {
                return $.fn[NAME$8] = JQUERY_NO_CONFLICT, ScrollSpy.jQueryInterface
            }
        }
    }));
    var Tab = function(_BaseComponent) {
        function Tab() {
            return _BaseComponent.apply(this, arguments) || this
        }
        _inheritsLoose(Tab, _BaseComponent);
        var _proto = Tab.prototype;
        return _proto.show = function() {
            var _this = this;
            if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active") || this._element.classList.contains("disabled"))) {
                var previous, target = getElementFromSelector(this._element),
                    listElement = this._element.closest(".nav, .list-group");
                if (listElement) {
                    var itemSelector = "UL" === listElement.nodeName || "OL" === listElement.nodeName ? ":scope > li > .active" : ".active";
                    previous = (previous = SelectorEngine.find(itemSelector, listElement))[previous.length - 1]
                }
                var hideEvent = null;
                if (previous && (hideEvent = EventHandler.trigger(previous, "hide.bs.tab", {
                        relatedTarget: this._element
                    })), !(EventHandler.trigger(this._element, "show.bs.tab", {
                        relatedTarget: previous
                    }).defaultPrevented || null !== hideEvent && hideEvent.defaultPrevented)) {
                    this._activate(this._element, listElement);
                    var complete = function() {
                        EventHandler.trigger(previous, "hidden.bs.tab", {
                            relatedTarget: _this._element
                        }), EventHandler.trigger(_this._element, "shown.bs.tab", {
                            relatedTarget: previous
                        })
                    };
                    target ? this._activate(target, target.parentNode, complete) : complete()
                }
            }
        }, _proto._activate = function(element, container, callback) {
            var _this2 = this,
                active = (!container || "UL" !== container.nodeName && "OL" !== container.nodeName ? SelectorEngine.children(container, ".active") : SelectorEngine.find(":scope > li > .active", container))[0],
                isTransitioning = callback && active && active.classList.contains("fade"),
                complete = function() {
                    return _this2._transitionComplete(element, active, callback)
                };
            if (active && isTransitioning) {
                var transitionDuration = getTransitionDurationFromElement(active);
                active.classList.remove("show"), EventHandler.one(active, "transitionend", complete), emulateTransitionEnd(active, transitionDuration)
            } else complete()
        }, _proto._transitionComplete = function(element, active, callback) {
            if (active) {
                active.classList.remove("active");
                var dropdownChild = SelectorEngine.findOne(":scope > .dropdown-menu .active", active.parentNode);
                dropdownChild && dropdownChild.classList.remove("active"), "tab" === active.getAttribute("role") && active.setAttribute("aria-selected", !1)
            }(element.classList.add("active"), "tab" === element.getAttribute("role") && element.setAttribute("aria-selected", !0), reflow(element), element.classList.contains("fade") && element.classList.add("show"), element.parentNode && element.parentNode.classList.contains("dropdown-menu")) && (element.closest(".dropdown") && SelectorEngine.find(".dropdown-toggle").forEach((function(dropdown) {
                return dropdown.classList.add("active")
            })), element.setAttribute("aria-expanded", !0));
            callback && callback()
        }, Tab.jQueryInterface = function(config) {
            return this.each((function() {
                var data = Data_getData(this, "bs.tab") || new Tab(this);
                if ("string" == typeof config) {
                    if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                    data[config]()
                }
            }))
        }, _createClass(Tab, null, [{
            key: "DATA_KEY",
            get: function() {
                return "bs.tab"
            }
        }]), Tab
    }(BaseComponent);
    EventHandler.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function(event) {
        event.preventDefault(), (Data_getData(this, "bs.tab") || new Tab(this)).show()
    })), onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn.tab;
            $.fn.tab = Tab.jQueryInterface, $.fn.tab.Constructor = Tab, $.fn.tab.noConflict = function() {
                return $.fn.tab = JQUERY_NO_CONFLICT, Tab.jQueryInterface
            }
        }
    }));
    var DefaultType$7 = {
            animation: "boolean",
            autohide: "boolean",
            delay: "number"
        },
        Default$7 = {
            animation: !0,
            autohide: !0,
            delay: 5e3
        },
        Toast = function(_BaseComponent) {
            function Toast(element, config) {
                var _this;
                return (_this = _BaseComponent.call(this, element) || this)._config = _this._getConfig(config), _this._timeout = null, _this._setListeners(), _this
            }
            _inheritsLoose(Toast, _BaseComponent);
            var _proto = Toast.prototype;
            return _proto.show = function() {
                var _this2 = this;
                if (!EventHandler.trigger(this._element, "show.bs.toast").defaultPrevented) {
                    this._clearTimeout(), this._config.animation && this._element.classList.add("fade");
                    var complete = function() {
                        _this2._element.classList.remove("showing"), _this2._element.classList.add("show"), EventHandler.trigger(_this2._element, "shown.bs.toast"), _this2._config.autohide && (_this2._timeout = setTimeout((function() {
                            _this2.hide()
                        }), _this2._config.delay))
                    };
                    if (this._element.classList.remove("hide"), reflow(this._element), this._element.classList.add("showing"), this._config.animation) {
                        var transitionDuration = getTransitionDurationFromElement(this._element);
                        EventHandler.one(this._element, "transitionend", complete), emulateTransitionEnd(this._element, transitionDuration)
                    } else complete()
                }
            }, _proto.hide = function() {
                var _this3 = this;
                if (this._element.classList.contains("show") && !EventHandler.trigger(this._element, "hide.bs.toast").defaultPrevented) {
                    var complete = function() {
                        _this3._element.classList.add("hide"), EventHandler.trigger(_this3._element, "hidden.bs.toast")
                    };
                    if (this._element.classList.remove("show"), this._config.animation) {
                        var transitionDuration = getTransitionDurationFromElement(this._element);
                        EventHandler.one(this._element, "transitionend", complete), emulateTransitionEnd(this._element, transitionDuration)
                    } else complete()
                }
            }, _proto.dispose = function() {
                this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), EventHandler.off(this._element, "click.dismiss.bs.toast"), _BaseComponent.prototype.dispose.call(this), this._config = null
            }, _proto._getConfig = function(config) {
                return config = _extends({}, Default$7, Manipulator.getDataAttributes(this._element), "object" == typeof config && config ? config : {}), typeCheckConfig("toast", config, this.constructor.DefaultType), config
            }, _proto._setListeners = function() {
                var _this4 = this;
                EventHandler.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', (function() {
                    return _this4.hide()
                }))
            }, _proto._clearTimeout = function() {
                clearTimeout(this._timeout), this._timeout = null
            }, Toast.jQueryInterface = function(config) {
                return this.each((function() {
                    var data = Data_getData(this, "bs.toast");
                    if (data || (data = new Toast(this, "object" == typeof config && config)), "string" == typeof config) {
                        if (void 0 === data[config]) throw new TypeError('No method named "' + config + '"');
                        data[config](this)
                    }
                }))
            }, _createClass(Toast, null, [{
                key: "DefaultType",
                get: function() {
                    return DefaultType$7
                }
            }, {
                key: "Default",
                get: function() {
                    return Default$7
                }
            }, {
                key: "DATA_KEY",
                get: function() {
                    return "bs.toast"
                }
            }]), Toast
        }(BaseComponent);
    return onDOMContentLoaded((function() {
        var $ = getjQuery();
        if ($) {
            var JQUERY_NO_CONFLICT = $.fn.toast;
            $.fn.toast = Toast.jQueryInterface, $.fn.toast.Constructor = Toast, $.fn.toast.noConflict = function() {
                return $.fn.toast = JQUERY_NO_CONFLICT, Toast.jQueryInterface
            }
        }
    })), {
        Alert: Alert,
        Button: Button,
        Carousel: Carousel,
        Collapse: Collapse,
        Dropdown: Dropdown,
        Modal: Modal,
        Popover: Popover,
        ScrollSpy: ScrollSpy,
        Tab: Tab,
        Toast: Toast,
        Tooltip: Tooltip
    }
}));